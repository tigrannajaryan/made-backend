# Generated by Django 2.1 on 2018-10-01 20:26

from django.db import migrations


def forwards(apps, schema_editor):
    schema_editor.execute(
        '''
        DO
        $do$
        begin
	

            create or replace view public.rpt_dates as
            select 
		        date_trunc( 'day', d)::date dt,
		        date_trunc( 'day', d - interval '1 week' + interval '1 day')::date dt_week_ago,
		        date_trunc( 'day', d - interval '1 month' + interval '1 day')::date dt_month_ago,
		        (current_timestamp < date_trunc( 'day', d)::date)::bool is_future
	        from generate_series
	                ( timestamp '2018-09-01' 
			        , current_timestamp + interval '3 months'
	                , interval '1 day') d
            ;
                

	        create or replace view public.rpt_staff_users as
	        select id
	        from public.user
	        where 'staff' = ANY(role)
	        ;


            create or replace view public.rpt_staff_stylist as
	        select s.id, s.user_id
	        from public.stylist s
		        inner join public.rpt_staff_users u
		        on s.user_id = u.id
            ;


            create or replace view public.rpt_staff_client as
	        select c.id, c.user_id
	        from public.client c
		        left join public.rpt_staff_users u
			        on c.user_id = u.id
		        left join public.rpt_staff_users s
			        on c.id = s.id
		        left join public.preferred_stylist p 
			        on s.id = p.stylist_id
	        where p.stylist_id is not null or u.id is not null
            ;
            
            
	        create or replace view public.rpt_user as
	        select u.id, 
		        u.is_active, 
		        u.is_staff, 
		        u.date_joined,
		        date_trunc( 'day', u.date_joined) dt_joined,
		        u.last_login,
		        ('stylist' = ANY( u.role))::int is_stylist,
		        ('client' = ANY( u.role))::int is_client,
		        (inv.created_client_id is not null)::int is_invitation
	        from public.user u
		        left join (
			        select c.user_id, max( i.created_client_id) created_client_id
			        from public.client c
				        left join public.client_of_stylist cs
					        on c.id = cs.client_id
				        left join public.invitation i
					        on cs.id = i.created_client_id
			        group by c.user_id) inv
		        on u.id = inv.user_id
			where 
				u.id not in (
					select user_id from public.rpt_staff_client
					union all
					select user_id from public.rpt_staff_stylist
				)	 
			;
	
	
	        create or replace view public.rpt_users_h as
	        select 
		        dt.dt,
		        date_trunc( 'week', dt.dt) "week",
		        sum( u.is_client) clients,
		        sum( u.is_stylist) stylists
	        from rpt_dates dt
		        left join public.rpt_user u
			        on u.dt_joined = dt.dt
			where 
				u.id not in (
					select user_id from public.rpt_staff_client
					union all
					select user_id from public.rpt_staff_stylist
				)
	        group by dt.dt
	        ;



            create or replace view public.rpt_appointment_service as
	        select 
		        aps.service_uuid,
		        a.datetime_start_at,
		        aps.regular_price,
		        aps.client_price,
		        aps.calculated_price
	        from public.appointment_service aps
		        inner join public.appointment a
		        on aps.appointment_id = a.id
            ;



			create or replace view public.rpt_distribution_clients_per_stylists as
			select 
				current_timestamp datetime,
				'booking' link_type,
				a.clients_count, 
				substring( '   ' || a.clients_count::varchar from '...$') s_clients_count, 
				count( distinct a.stylist_id) stylist_count
			from (
				select count( distinct t.client_id) clients_count, stylist_id
				from public.appointment t
					left join rpt_staff_client sc 
						on t.client_id = sc.id
					left join rpt_staff_stylist ss 
						on t.stylist_id = ss.id
				where sc.id is null and ss.id is null
				group by stylist_id
				) a
			group by a.clients_count
			union all
			select 
				current_timestamp datetime,
				'preferred stylist' link_type,
				a.clients_count, 
				substring( '   ' || a.clients_count::varchar from '...$') s_clients_count, 
				count( distinct a.stylist_id) stylist_count
			from (
				select count( distinct t.client_id) clients_count, stylist_id
				from public.preferred_stylist t
					left join rpt_staff_client sc 
						on t.client_id = sc.id
					left join rpt_staff_stylist ss 
						on t.stylist_id = ss.id
				where sc.id is null and ss.id is null
					and t.deleted_at is null
				group by stylist_id
				) a
			group by a.clients_count
			;

	
			create or replace view public.rpt_distribution_stylists_per_clients as
			select 
				a.stylists_count, 
				substring( '   ' || a.stylists_count::varchar from '...$') s_stylists_count, 
				count( distinct a.client_id) client_count,
				current_timestamp datetime
			from (
				select t.client_id, 
					count( distinct t.stylist_id) stylists_count
				from public.appointment t
					left join rpt_staff_client sc 
						on t.client_id = sc.id
					left join rpt_staff_stylist ss 
						on t.stylist_id = ss.id
				where 1 = 1 and sc.id is null and ss.id is null
				group by client_id
				) a
			group by a.stylists_count
			;
	
	
			create or replace view public.rpt_distribution_pareto_stylist_client as
			select 
				current_timestamp datetime,
				(sum( a.clients_count) over ( order by a.clients_count desc, a.stylist_id))/
					(sum( a.clients_count) over ( partition by a.g))::float clients_percent, 
				(count( a.stylist_id) over ( order by a.clients_count desc, a.stylist_id))/
					(count( a.stylist_id) over ( partition by a.g))::float stylist_percent
			from (
				select 
					count( distinct client_id) clients_count, 
					stylist_id, 
					1 g
				from public.appointment t
					left join rpt_staff_client sc 
						on t.client_id = sc.id
					left join rpt_staff_stylist ss 
						on t.stylist_id = ss.id
				where sc.id is null and ss.id is null
				group by stylist_id
				) a
			union 
			select current_timestamp, .0, .0
			;



	        create or replace view public.rpt_booking as
	        select
		        b.id,
		        b.datetime_start_at,
		        date_trunc( 'day', b.datetime_start_at) dt_start_at,
		        case when current_timestamp < date_trunc('day', b.datetime_start_at)::date + interval '1 week' - interval '1 day'  
			        then 1 else null 
			        end :: integer is_last_week,
		        case when current_timestamp < date_trunc('day', b.datetime_start_at)::date + interval '1 month' - interval '1 day'  
			        then 1 else null 
			        end :: integer is_last_month,
		        b.stylist_id,
		        (b.status = 'checked_out')::int is_checked_out,
		        (b.status in ( 'cancelled_by_client', 'cancelled_by_stylist'))::int is_cancelled,
		        b.grand_total,
		        srv.is_discount,
		        case when srv.discount_amount > 0 
			        then srv.discount_amount else null 
			        end discount_amount,
		        lag( b.datetime_start_at, 1, b.datetime_start_at - interval '100 years') over previous_booking previous_booking_date,
		        (b.datetime_start_at - interval '3 months' <
		        lag( b.datetime_start_at, 1, b.datetime_start_at - interval '100 years') over previous_booking)::int rebooking_3_months,
		        (b.datetime_start_at - interval '6 months' <
		        lag( b.datetime_start_at, 1, b.datetime_start_at - interval '100 years') over previous_booking)::int rebooking_6_months,
		        srv.services_count,
		        (srv.services_count >= 2)::int is_two_and_more_services
	        from public.appointment b
		        left join (
			        select s.appointment_id,
				        sum( s.regular_price - s.client_price) discount_amount,
				        max(( s.applied_discount is not null)::int) is_discount,
				        count( s.id) services_count
			        from public.appointment_service s
			        group by s.appointment_id
		        ) srv
			        on b.id = srv.appointment_id
		         left join public.rpt_staff_client sc
		         	on b.client_id = sc.id
		         left join public.rpt_staff_stylist ss
		         	on b.stylist_id = ss.id
         	where 1 = 1
         		and	sc.id is null
		        and ss.id is null
	        window previous_booking as (partition by b.client_id order by b.datetime_start_at)
	        ;

	
	        create or replace view public.rpt_booking_h as
	        select 
		        weekly.dt,
		        weekly.weekly_stylists,
		        weekly.weekly_bookings,
		        weekly.weekly_bookings_per_stylist,
		        weekly_revenue.weekly_avg_stylist_revenue,
		        weekly_revenue.weekly_median_stylist_revenue,
		        monthly.monthly_stylists,
		        monthly.monthly_bookings,
		        monthly.monthly_bookings_per_stylist,
		        monthly.monthly_avg_stylist_revenue
	        from (
			        select 
				        d.dt,
				        count( distinct b.stylist_id) as weekly_stylists,
				        count( b.id) as weekly_bookings,
				        count( b.id) / count( distinct b.stylist_id)::float as weekly_bookings_per_stylist
			        from
				        public.rpt_dates d
				        left join public.rpt_booking b
					        on b.dt_start_at between d.dt_week_ago and d.dt
			        where d.is_future = false
			        group by d.dt
		        ) weekly
		        inner join (
			        select 
					        d.dt dt2,
					        count( distinct b.stylist_id) as monthly_stylists,
					        count( distinct b.id) as monthly_bookings,
					        count( distinct b.id) / count( distinct b.stylist_id)::float as monthly_bookings_per_stylist,
					        sum( b.grand_total) / count( distinct b.stylist_id)::float as monthly_avg_stylist_revenue
				        from
					        public.rpt_dates d
					        left join public.rpt_booking b
						        on b.dt_start_at between d.dt_month_ago and d.dt
				        where d.is_future = false
				        group by d.dt
		        ) monthly
			        on weekly.dt = monthly.dt2
		        inner join (
			        select
				        r.dt,
				        avg( r.stylist_revenue) weekly_avg_stylist_revenue,
				        percentile_cont( .5) within group (order by r.stylist_revenue) as weekly_median_stylist_revenue
			        from (
				        select 
					        d.dt, 
					        b.stylist_id	,
					        sum( b.grand_total)::float as stylist_revenue
				        from
					        public.rpt_dates d
					        left join public.rpt_booking b
						        on b.dt_start_at between d.dt_week_ago and d.dt
				        where d.is_future = false
				        group by d.dt, b.stylist_id
				        ) r
			        group by r.dt
		        ) weekly_revenue
			        on weekly.dt = weekly_revenue.dt
	        ;

	
		 	create or replace view public.rpt_stylist as
			select 
				st.id stylist_id,
				coalesce( srv.stylist_services_count, 0) stylist_services_count,
				srv.avg_regular_price,
				coalesce( wd.weekday_discounts_count, 0)::int weekday_discounts_count,
				case when coalesce( wd.weekday_discounts_count, 0) > 0 
					then 1 else 0 
					end is_daily_discount,
				coalesce( wd.avg_weekday_discount, 0) avg_weekday_discount,
				(0 < any( st.rebook_discounts))::int is_loyalty_discount,
				case when 0 = all( st.rebook_discounts)
					then 0::float
					else
					(select avg( nullif( discount, 0)) from unnest( st.rebook_discounts) discount)
					end avg_loyalty_discount,
				(st.rebook_within_1_week_discount_percent > 0)::int is_first_week_discount,
				st.first_time_book_discount_percent,
				st.rebook_within_1_week_discount_percent,
				(st.maximum_discount > 0 and st.is_maximum_discount_enabled)::int is_maximum_discount_enabled,
				case when not st.is_maximum_discount_enabled 
					then null else st.maximum_discount 
					end maximum_discount,
				(0 = all( st.rebook_discounts || 
					array[
						st.is_maximum_discount_enabled::int4,
						coalesce( wd.weekday_discounts_count, 0)::int4
						]))::int no_discount_count
			from (
					select *,
						array[ rebook_within_1_week_discount_percent,
							rebook_within_2_weeks_discount_percent,
							rebook_within_3_weeks_discount_percent, 
							rebook_within_4_weeks_discount_percent,
							rebook_within_5_weeks_discount_percent,
							rebook_within_6_weeks_discount_percent] rebook_discounts
					from public.stylist
				) st
				left join (
					select ss.stylist_id, 
						count( ss.id) stylist_services_count, 
						avg( ss.regular_price) avg_regular_price
					from public.stylist_service ss
					where ss.is_enabled = true and ss.deleted_at is null
					group by ss.stylist_id
				) srv
					on st.id = srv.stylist_id
				left join (
					select swd.stylist_id, 
						count( swd.id) weekday_discounts_count,
						avg( swd.discount_percent) avg_weekday_discount
					from public.stylist_weekday_discount swd
					where swd.discount_percent > 0
					group by swd.stylist_id
				) wd
					on st.id = wd.stylist_id
				left join public.rpt_staff_stylist ss
					on st.id = ss.id
			where ss.id is null		
	        ;
            
            
        end
        $do$;
        '''
    )


def backwards(apps, schema_editor):
    schema_editor.execute(
        '''
        DO
        $do$
        begin
        
            drop view if exists public.rpt_appointment_service cascade;

            drop view if exists public.rpt_distribution_clients_per_stylists cascade;
                
            drop view if exists public.rpt_distribution_stylists_per_clients cascade;
                
            drop view if exists public.rpt_distribution_pareto_stylist_client cascade;
                
            drop view if exists public.rpt_stylist cascade;
                
            drop view if exists public.rpt_dates cascade;
                
            drop view if exists public.rpt_booking_h cascade;
            
            drop view if exists public.rpt_booking cascade;
                
            drop view if exists public.rpt_staff_client cascade;
                
            drop view if exists public.rpt_staff_stylist cascade;
                
            drop view if exists public.rpt_staff_users cascade;

            drop view if exists public.rpt_users_h cascade;
                
            drop view if exists public.rpt_user cascade;

        end
        $do$;
        '''
    )


class Migration(migrations.Migration):

    dependencies = [
        ('appointment', '0027_appointment_phone_from_user'),
        ('client', '0019_client_location_from_zipcode'),
        ('core', '0029_auto_20180927_1112'),
        ('salon', '0053_auto_20180906_1248')
    ]

    operations = [
        migrations.RunPython(forwards, backwards)
    ]
