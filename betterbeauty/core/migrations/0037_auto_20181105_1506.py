# Generated by Django 2.1 on 2018-11-05 20:06

from django.db import migrations


def forward(app, schema_editor):
    schema_editor.execute(
        '''
        DO
        $do$
        begin
            drop view if exists public.rpt_user cascade;

            create or replace view public.rpt_user as
            select u.id,
                u.is_active,
                ('staff' = ANY( u.role) or u.is_staff)::int is_staff,
                u.date_joined,
                date_trunc( 'day', u.date_joined) dt_joined,
                u.last_login,
                ('stylist' = ANY( u.role))::int is_stylist,
                ('client' = ANY( u.role))::int is_client,
                (inv.created_client_id is not null)::int is_invitation,
                c.id client_id,
                s.id stylist_id,
                u.first_name,
                u.last_name,
                u.phone,
                case when u.email like '%%madebeauty.com' then '' else u.email end email,
                u.role::varchar roles,
                s.instagram_url,
                s.website_url,
                sl."name" salon_name,
                sl.address salon_address,
                (case when u.first_name is null then 0 else 1 end +
                    case when u.last_name is null then 0 else 1 end +
                    case when u.email like '%%madebeauty.com' then 0 else 1 end +
                    case when u.phone is null then 0 else 1 end) / 4. client_completeness,
                (case when u.first_name is null then 0 else 1 end +
                    case when u.last_name is null then 0 else 1 end +
                    case when u.email like '%%madebeauty.com' then 0 else 1 end +
                    case when u.phone is null then 0 else 1 end +
                    case when s.instagram_url is null then 0 else 1 end +
                    case when s.website_url is null then 0 else 1 end +
                    case when sl.address is null then 0 else 1 end) / 7. stylist_completeness,
                case when u.phone is null then 0 else 1 end is_phone
            from public.user u
                left join (
                    select c.user_id, max( i.created_client_id) created_client_id
                    from public.client c
                        left join public.invitation i
                            on c.id = i.created_client_id
                    group by c.user_id) inv
                on u.id = inv.user_id
                left join public.stylist s
                    on u.id = s.user_id
                left join public.salon sl
                    on s.salon_id = sl.id
                left join public.client c
                    on u.id = c.user_id
            where 'staff' != all( u.role)
                and u.is_staff = false
                and (c.id is null
                    or c.id not in (
                        select p.client_id
                        from public.preferred_stylist p
                            inner join public.stylist s2
                                on p.stylist_id = s2.id
                            inner join public."user" u2
                                on s2.user_id =  u2.id
                        where 'staff' = any( u2.role)
                        )
                    )
            ;


            drop view if exists public.rpt_users_h cascade;

            create or replace view public.rpt_users_h as
            select distinct
                dt.dt,
                date_trunc( 'week', dt.dt) "week",
                sum( u.is_client) over (partition by dt.dt) clients,
                sum( u.is_stylist) over (partition by dt.dt) stylists,
                sum( u.is_client) over (order by dt.dt) rolling_clients,
                sum( u.is_stylist) over (order by dt.dt) rolling_stylists,
                sum( u.is_phone) over (partition by dt.dt) phones,
                sum( u.is_phone) over (order by dt.dt) rolling_phones,
                sum( case u.client_completeness when 1 then 1 else 0 end) over (partition by dt.dt) completed_clients,
                sum( case u.client_completeness when 1 then 1 else 0 end) over (order by dt.dt) rolling_completed_clients
            from rpt_dates dt
                left join public.rpt_user u
                    on u.dt_joined = dt.dt
            where
                u.is_staff = 0;


            drop view if exists public.rpt_stylist cascade;

            create or replace view public.rpt_stylist as
            select
                st.id stylist_id,
                coalesce( srv.stylist_services_count, 0) stylist_services_count,
                srv.avg_regular_price,
                coalesce( wd.weekday_discounts_count, 0)::int weekday_discounts_count,
                case when coalesce( wd.weekday_discounts_count, 0) > 0
                    then 1 else 0
                    end is_daily_discount,
                coalesce( wd.avg_weekday_discount, 0) avg_weekday_discount,
                (0 < any( st.rebook_discounts))::int is_loyalty_discount,
                case when 0 = all( st.rebook_discounts)
                    then 0::float
                    else
                    (select avg( nullif( discount, 0)) from unnest( st.rebook_discounts) discount)
                    end avg_loyalty_discount,
                (st.rebook_within_1_week_discount_percent > 0)::int is_first_week_discount,
                st.first_time_book_discount_percent,
                st.rebook_within_1_week_discount_percent,
                (st.maximum_discount > 0 and st.is_maximum_discount_enabled)::int is_maximum_discount_enabled,
                case when not st.is_maximum_discount_enabled
                    then null else st.maximum_discount
                    end maximum_discount,
                (0 = all( st.rebook_discounts ||
                    array[
                        st.is_maximum_discount_enabled::int4,
                        coalesce( wd.weekday_discounts_count, 0)::int4
                        ]))::int no_discount_count
            from (
                    select *,
                        array[ rebook_within_1_week_discount_percent,
                            rebook_within_2_weeks_discount_percent,
                            rebook_within_3_weeks_discount_percent,
                            rebook_within_4_weeks_discount_percent
                            ] rebook_discounts
                    from public.stylist
                ) st
                left join (
                    select ss.stylist_id,
                        count( ss.id) stylist_services_count,
                        avg( ss.regular_price) avg_regular_price
                    from public.stylist_service ss
                    where ss.is_enabled = true and ss.deleted_at is null
                    group by ss.stylist_id
                ) srv
                    on st.id = srv.stylist_id
                left join (
                    select swd.stylist_id,
                        count( swd.id) weekday_discounts_count,
                        avg( swd.discount_percent) avg_weekday_discount
                    from public.stylist_weekday_discount swd
                    where swd.discount_percent > 0
                    group by swd.stylist_id
                ) wd
                    on st.id = wd.stylist_id
                inner join public.rpt_user ss
                    on st.id = ss.stylist_id
            ;


            drop view if exists public.rpt_booking cascade;

            create or replace view public.rpt_booking as
            select
                b.id,
                b.datetime_start_at,
                date_trunc( 'day', b.datetime_start_at) dt_start_at,
                to_char( b.datetime_start_at, 'YYYY-MM-DD HH24:MI') datetime_start_at_,
                b.created_at,
                to_char( b.created_at, 'YYYY-MM-DD HH24:MI') created_at_,
                case when current_timestamp < date_trunc('day', b.datetime_start_at)::date + interval '1 week' - interval '1 day'
                    then 1 else null
                    end :: integer is_last_week,
                case when current_timestamp < date_trunc('day', b.datetime_start_at)::date + interval '1 month' - interval '1 day'
                    then 1 else null
                    end :: integer is_last_month,
                b.stylist_id,
                b.status,
                (b.status = 'checked_out')::int is_checked_out,
                (b.status in ( 'cancelled_by_client', 'cancelled_by_stylist'))::int is_cancelled,
                b.grand_total,
                srv.is_discount,
                case when srv.discount_amount > 0
                    then srv.discount_amount else null
                    end discount_amount,
                lag( b.datetime_start_at, 1, b.datetime_start_at - interval '100 years') over previous_booking previous_booking_date,
                (b.datetime_start_at - interval '3 months' <
                    lag( b.datetime_start_at, 1, b.datetime_start_at - interval '100 years') over previous_booking)::int rebooking_3_months,
                (b.datetime_start_at - interval '6 months' <
                    lag( b.datetime_start_at, 1, b.datetime_start_at - interval '100 years') over previous_booking)::int rebooking_6_months,
                srv.services_count,
                (srv.services_count >= 2)::int is_two_and_more_services,
                trim(b.client_first_name || ' ' || b.client_last_name) client,
                trim(cc.first_name || ' ' || cc.last_name) client2,
                b.client_phone,
                trim(ss.first_name || ' ' || ss.last_name) stylist,
                ss.phone stylist_phone,
                sl."name" salon,
                srv.services
            from public.appointment b
                left join (
                    select s.appointment_id,
                        sum( s.regular_price - s.client_price) discount_amount,
                        max(( s.applied_discount is not null)::int) is_discount,
                        count( s.id) services_count,
                        array_to_string( array_agg( s.service_name || ' ($' || s.regular_price ||
                            ' -' || s.discount_percentage || '%% -> $' || s.client_price || ')'), ',
            ') services
                    from public.appointment_service s
                    group by s.appointment_id
                ) srv
                    on b.id = srv.appointment_id
                inner join public.rpt_user sc
                    on b.client_id = sc.client_id
                inner join public.rpt_user ss
                    on b.stylist_id = ss.stylist_id
                left join public.stylist s
                    on b.stylist_id = s.id
                left join public.salon sl
                    on sl.id = s.salon_id
                left join public.rpt_user cc
                    on b.created_by_id = cc.id
            window previous_booking as (partition by b.client_id order by b.datetime_start_at)
            ;


            drop view if exists public.rpt_booking_h cascade;

            create or replace view public.rpt_booking_h as
            select
                weekly.dt,
                weekly.weekly_stylists,
                weekly.weekly_bookings,
                case weekly.weekly_stylists
                    when 0 then null
                    else weekly.weekly_bookings / weekly.weekly_stylists
                    end weekly_bookings_per_stylist,
                weekly_revenue.weekly_avg_stylist_revenue,
                weekly_revenue.weekly_median_stylist_revenue,
                monthly.monthly_stylists,
                monthly.monthly_bookings,
                case monthly.monthly_stylists
                    when 0 then null
                    else monthly.monthly_bookings / monthly.monthly_stylists
                    end monthly_bookings_per_stylist,
                case monthly.monthly_stylists
                    when 0 then null
                    else monthly.monthly_revenue / monthly.monthly_stylists
                    end monthly_avg_stylist_revenue,
                sum(daily.daily_bookings) over (partition by weekly.dt) daily_bookings,
                sum(daily.daily_bookings) over (order by weekly.dt) rolling_daily_bookings,
                sum(daily.daily_revenue) over (partition by weekly.dt) daily_revenue,
                sum(daily.daily_revenue) over (order by weekly.dt) rolling_daily_revenue
            from (
                    select
                        d.dt,
                        count( distinct b.stylist_id) as weekly_stylists,
                        count( b.id) as weekly_bookings
                    from
                        public.rpt_dates d
                        left join public.rpt_booking b
                            on b.dt_start_at between d.dt_week_ago and d.dt
                    where d.is_future = false
                    group by d.dt
                ) weekly
                inner join (
                    select
                            d.dt dt2,
                            count( distinct b.stylist_id) as monthly_stylists,
                            count( distinct b.id) as monthly_bookings,
                            sum( b.grand_total) as monthly_revenue
                        from
                            public.rpt_dates d
                            left join public.rpt_booking b
                                on b.dt_start_at between d.dt_month_ago and d.dt
                        where d.is_future = false
                        group by d.dt
                ) monthly
                    on weekly.dt = monthly.dt2
                inner join (
                    select
                        r.dt,
                        avg( r.stylist_revenue) weekly_avg_stylist_revenue,
                        percentile_cont( .5) within group (order by r.stylist_revenue) as weekly_median_stylist_revenue
                    from (
                        select
                            d.dt,
                            b.stylist_id	,
                            sum( b.grand_total)::float as stylist_revenue
                        from
                            public.rpt_dates d
                            left join public.rpt_booking b
                                on b.dt_start_at between d.dt_week_ago and d.dt
                        where d.is_future = false
                        group by d.dt, b.stylist_id
                        ) r
                    group by r.dt
                ) weekly_revenue
                    on weekly.dt = weekly_revenue.dt
                inner join (
                    select
                        d.dt dt3,
                        count( distinct b.stylist_id) as daily_stylists,
                        count( b.id) as daily_bookings,
                        sum( b.grand_total) as daily_revenue
                    from
                        public.rpt_dates d
                        left join public.rpt_booking b
                            on b.dt_start_at = d.dt
                    where d.is_future = false
                    group by d.dt
                ) daily
                    on weekly.dt = daily.dt3
            ;


            drop view if exists public.rpt_distribution_clients_per_stylists cascade;

            create or replace view public.rpt_distribution_clients_per_stylists as
            select
                current_timestamp datetime,
                'booking' link_type,
                a.clients_count,
                substring( '   ' || a.clients_count::varchar from '...$') s_clients_count,
                count( distinct a.stylist_id) stylist_count
            from (
                select count( distinct t.client_id) clients_count, s.stylist_id
                from public.rpt_user s
                    left join public.appointment t
                        on s.stylist_id = t.stylist_id
                    left join public.rpt_user c
                        on t.client_id = c.client_id
                where s.is_stylist = 1
                group by s.stylist_id
                ) a
            group by a.clients_count
            union all
            select
                current_timestamp datetime,
                'preferred stylist' link_type,
                a.clients_count,
                substring( '   ' || a.clients_count::varchar from '...$') s_clients_count,
                count( distinct a.stylist_id) stylist_count
            from (
                select count( distinct t.client_id) clients_count, us.stylist_id
                from public.rpt_user us
                    left join public.preferred_stylist t
                        on t.stylist_id = us.stylist_id and t.deleted_at is null
                    left join public.rpt_user c
                        on t.client_id = c.client_id
                where us.is_stylist = 1
                group by us.stylist_id
                ) a
            group by a.clients_count
            ;


            drop view if exists public.rpt_distribution_pareto_stylist_client cascade;

            create or replace view public.rpt_distribution_pareto_stylist_client as
            SELECT
                datetime,
                clients_percent,
                stylist_percent,
                date '2018-01-01' + round( stylist_percent*100)::integer fake_date
            FROM (
                select
                    current_timestamp datetime,
                    (sum( a.clients_count) over ( order by a.clients_count desc, a.stylist_id))/
                        (sum( a.clients_count) over ( partition by a.g))::float clients_percent,
                    (count( a.stylist_id) over ( order by a.clients_count desc, a.stylist_id))/
                        (count( a.stylist_id) over ( partition by a.g))::float stylist_percent
                from (
                    select
                        count( distinct t.client_id) clients_count,
                        t.stylist_id,
                        1 g
                    from public.appointment t
                        inner join public.rpt_user uc
                            on t.client_id = uc.client_id
                --				and u.is_staff = 0
                        inner join public.rpt_user us
                            on t.stylist_id = us.stylist_id
                --				and us.is_staff = 0
                    group by t.stylist_id
                    ) a
                union
                select current_timestamp, .0, .0
                ) T
                ;


            drop view if exists public.rpt_distribution_stylists_per_clients cascade;

            create or replace view public.rpt_distribution_stylists_per_clients as
            select
                a.stylists_count,
                substring( '   ' || a.stylists_count::varchar from '...$') s_stylists_count,
                count( distinct a.client_id) client_count,
                current_timestamp datetime
            from (
                select c.client_id,
                    count( distinct t.stylist_id) stylists_count
                from public.rpt_user c
                    left join public.appointment t
                        on t.client_id = c.client_id
                    left join 	public.rpt_user s
                        on t.stylist_id = s.stylist_id
                where c.is_client = 1
                group by c.client_id
                ) a
            group by a.stylists_count
            ;
        end
        $do$;
        '''
    )

class Migration(migrations.Migration):

    dependencies = [
        ('core', '0036_remove_client_role_for_stylists'),
        ('appointment', '0033_remove_appointment_real_client'),
        ('client', '0022_auto_20181024_1246'),
        ('salon', '0064_auto_20181030_1135')
    ]

    operations = [
        migrations.RunPython(forward, migrations.RunPython.noop),
    ]
