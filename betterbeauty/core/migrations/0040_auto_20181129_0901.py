# Generated by Django 2.1 on 2018-11-29 14:01

from django.db import migrations


def forward(app, schema_editor):
    schema_editor.execute(
        '''
        DO
        $do$
        begin


            drop view if exists public.rpt_appointment_service cascade;

            create or replace view public.rpt_appointment_service as
            select
                aps.service_uuid,
                a.datetime_start_at,
                aps.regular_price,
                aps.client_price,
                aps.calculated_price
            from public.appointment_service aps
                inner join public.appointment a
                on aps.appointment_id = a.id
            ;


            drop view if exists public.rpt_missed_views;

            create or replace view public.rpt_missed_views as
            select
                'ebdb' table_catalog,
                'public' table_schema,
                unnest(array[
                    'rpt_client_funnel',
                    'rpt_stylist_funnel',
                    'rpt_distribution_stylists_per_clients',
                    'rpt_distribution_clients_per_stylists',
                    'rpt_distribution_pareto_stylist_client',
                    'rpt_appointment_service',
                    'rpt_booking_h',
                    'rpt_booking',
                    'rpt_stylist',
                    'rpt_users_h',
                    'rpt_user',
                    'rpt_all_users',
                    'rpt_dates']) table_name
            except
            select
                table_catalog,
                table_schema,
                table_name
            from information_schema.tables
            where table_type = 'VIEW'
                and  table_name like 'rpt%%'
            ;


            drop view if exists public.rpt_all_users cascade;

            create or replace view public.rpt_all_users as
            select u.id,
                u.is_active,
                ('staff' = ANY( u.role) or u.is_staff)::int is_staff,
                ((c.id is not null
                    and c.id in (
                        select p.client_id
                        from public.preferred_stylist p
                            inner join public.stylist s2
                                on p.stylist_id = s2.id
                            inner join public."user" u2
                                on s2.user_id =  u2.id
                        where 'staff' = any( u2.role)
                            and p.deleted_at is null
                        )
                    ))::int is_staff_affiliated,
                u.date_joined,
                date_trunc( 'day', u.date_joined) dt_joined,
                u.last_login,
                ('stylist' = ANY( u.role) and u.phone is not null)::int is_stylist,
                ('stylist' = ANY( u.role) and u.phone is null)::int is_partial_stylist,
                ('client' = ANY( u.role))::int is_client,
                (inv.created_client_id is not null)::int is_invitation,
                c.id client_id,
                s.id stylist_id,
                u.first_name,
                u.last_name,
                u.phone,
                case when u.email  similar to '(client|stylist)(-?[0-9a-f]{4}){8}@madebeauty.com' then '' else u.email end email,
                u.role::varchar roles,
                s.instagram_url,
                s.website_url,
                sl."name" salon_name,
                sl.address salon_address,
                (case when coalesce( u.first_name, '') = '' then 0 else 1 end +
                    case when coalesce( u.last_name, '') = '' then 0 else 1 end +
                    case when u.phone is null then 0 else 1 end) / 3. client_completeness,
                (case when coalesce( u.first_name, '') = '' then 0 else 1 end +
                    case when coalesce( u.last_name, '') = '' then 0 else 1 end +
                    case when u.email similar to 'stylist(-?[0-9a-f]{4}){8}@madebeauty.com' then 0 else 1 end +
                    case when u.phone is null then 0 else 1 end +
                    case when s.instagram_url is null then 0 else 1 end +
                    case when s.website_url is null then 0 else 1 end +
                    case when sl.address is null then 0 else 1 end) / 7. stylist_completeness,
                case when u.phone is null then 0 else 1 end is_phone,
                (select count(distinct p3.stylist_id)
                    from public.preferred_stylist p3
                    where p3.client_id = c.id
                        and p3.deleted_at is null) preferred_stylists_count,
                services.service_count,
                working_hours.working_hours_count,
                (u.phone is not null 
                    and coalesce( services.service_count, 0) > 0 
                    and coalesce( working_hours.working_hours_count, 0) > 0) is_profile_bookable
            from public.user u
                left join (
                    -- invitations if any
                    select c.user_id, max( i.created_client_id) created_client_id
                    from public.client c
                        left join public.invitation i
                            on c.id = i.created_client_id
                    group by c.user_id) inv
                on u.id = inv.user_id
                left join public.stylist s
                    on u.id = s.user_id
                left join public.salon sl
                    on s.salon_id = sl.id
                left join public.client c
                    on u.id = c.user_id
                left join (
                    -- count services if any
                    select services.stylist_id, count(services.id) service_count
                    from public.stylist_service services
                    group by services.stylist_id
                ) services
                    on s.id = services.stylist_id
                left join (
                    -- count working hours if any
                    select working_hours.stylist_id, count(working_hours.id) working_hours_count
                    from public.stylist_available_day working_hours
                    where working_hours.is_available = True
                        and working_hours.work_start_at is not null
                        and working_hours.work_end_at is not null
                    group by working_hours.stylist_id
                ) working_hours
                    on s.id = working_hours.stylist_id
            ;


            drop view if exists public.rpt_user cascade;

            create or replace view public.rpt_user as
            select *
            from public.rpt_all_users
            where is_staff = 0
            ;

            drop view if exists public.rpt_stylist cascade;

            create or replace view public.rpt_stylist as
            select 
                st.id stylist_id,
                coalesce( srv.stylist_services_count, 0) stylist_services_count,
                srv.avg_regular_price,
                coalesce( wd.weekday_discounts_count, 0)::int weekday_discounts_count,
                case when coalesce( wd.weekday_discounts_count, 0) > 0 
                    then 1 else 0 
                    end is_daily_discount,
                coalesce( wd.avg_weekday_discount, 0) avg_weekday_discount,
                (0 < any( st.rebook_discounts))::int is_loyalty_discount,
                case when 0 = all( st.rebook_discounts)
                    then 0::float
                    else
                    (select avg( nullif( discount, 0)) from unnest( st.rebook_discounts) discount)
                    end avg_loyalty_discount,
                (st.rebook_within_1_week_discount_percent > 0)::int is_first_week_discount,
                st.first_time_book_discount_percent,
                st.rebook_within_1_week_discount_percent,
                (st.maximum_discount > 0 and st.is_maximum_discount_enabled)::int is_maximum_discount_enabled,
                case when not st.is_maximum_discount_enabled 
                    then null else st.maximum_discount 
                    end maximum_discount,
                (0 = all( st.rebook_discounts || 
                    array[
                        st.is_maximum_discount_enabled::int4,
                        coalesce( wd.weekday_discounts_count, 0)::int4
                        ]))::int no_discount_count
            from (
                    select *,
                        array[ rebook_within_1_week_discount_percent,
                            rebook_within_2_weeks_discount_percent,
                            rebook_within_3_weeks_discount_percent, 
                            rebook_within_4_weeks_discount_percent
                            ] rebook_discounts
                    from public.stylist
                ) st
                left join (
                    select ss.stylist_id, 
                        count( ss.id) stylist_services_count, 
                        avg( ss.regular_price) avg_regular_price
                    from public.stylist_service ss
                    where ss.is_enabled = true and ss.deleted_at is null
                    group by ss.stylist_id
                ) srv
                    on st.id = srv.stylist_id
                left join (
                    select swd.stylist_id, 
                        count( swd.id) weekday_discounts_count,
                        avg( swd.discount_percent) avg_weekday_discount
                    from public.stylist_weekday_discount swd
                    where swd.discount_percent > 0
                    group by swd.stylist_id
                ) wd
                    on st.id = wd.stylist_id
                inner join public.rpt_user ss
                    on st.id = ss.stylist_id and ss.is_partial_stylist = 0
            ;


            drop view if exists public.rpt_users_h cascade;

            create or replace view public.rpt_users_h as
            select distinct
                dt.dt,
                date_trunc( 'week', dt.dt) "week",
                sum( coalesce( u.is_client, 0)) over (partition by dt.dt) clients,
                sum( coalesce( u.is_stylist, 0)) over (partition by dt.dt) stylists,
                sum( coalesce( u.is_client, 0)) over (order by dt.dt) rolling_clients,
                sum( coalesce( u.is_stylist, 0)) over (order by dt.dt) rolling_stylists,
                sum( coalesce( u.is_phone, 0)) over (partition by dt.dt) phones,
                sum( coalesce( u.is_phone, 0)) over (order by dt.dt) rolling_phones,
                sum( case u.client_completeness when 1 then 1 else 0 end) over (partition by dt.dt) completed_clients,
                sum( case u.client_completeness when 1 then 1 else 0 end) over (order by dt.dt) rolling_completed_clients
            from rpt_dates dt
                left join public.rpt_user u
                    on u.dt_joined = dt.dt and u.is_staff = 0 and u.is_partial_stylist = 0
            ;


            drop view if exists public.rpt_booking cascade;

            create or replace view public.rpt_booking as
            select
                b.id,
                b.datetime_start_at,
                date_trunc( 'day', b.datetime_start_at) dt_start_at,
                to_char( b.datetime_start_at, 'YYYY-MM-DD HH24:MI') datetime_start_at_,
                b.created_at,
                to_char( b.created_at, 'YYYY-MM-DD HH24:MI') created_at_,
                case when current_timestamp < date_trunc('day', b.datetime_start_at)::date + interval '1 week' - interval '1 day'  
                    then 1 else null 
                    end :: integer is_last_week,
                case when current_timestamp < date_trunc('day', b.datetime_start_at)::date + interval '1 month' - interval '1 day'  
                    then 1 else null 
                    end :: integer is_last_month,
                b.stylist_id,
                b.status,
                (b.status = 'checked_out')::int is_checked_out,
                (b.status in ( 'cancelled_by_client', 'cancelled_by_stylist'))::int is_cancelled,
                b.grand_total,
                srv.is_discount,
                case when srv.discount_amount > 0 
                    then srv.discount_amount else null 
                    end discount_amount,
                lag( b.datetime_start_at, 1, b.datetime_start_at - interval '100 years') over previous_booking previous_booking_date,
                (b.datetime_start_at - interval '3 months' <
                    lag( b.datetime_start_at, 1, b.datetime_start_at - interval '100 years') over previous_booking)::int rebooking_3_months,
                (b.datetime_start_at - interval '6 months' <
                    lag( b.datetime_start_at, 1, b.datetime_start_at - interval '100 years') over previous_booking)::int rebooking_6_months,
                srv.services_count,
                (srv.services_count >= 2)::int is_two_and_more_services,
                b.client_id,
                trim(b.client_first_name || ' ' || b.client_last_name) client,
                trim(cc.first_name || ' ' || cc.last_name) client2,
                b.client_phone,
                trim(ss.first_name || ' ' || ss.last_name) stylist,
                ss.phone stylist_phone,
                sl."name" salon,
                srv.services,
                (auto_checkout.appointment_id is not null)::int is_auto_checkout
            from public.appointment b
                left join (
                    select s.appointment_id,
                        sum( s.regular_price - s.client_price) discount_amount,
                        max(( s.applied_discount is not null)::int) is_discount,
                        count( s.id) services_count,
                        array_to_string( array_agg( s.service_name || ' ($' || s.regular_price || 
                            ' -' || s.discount_percentage || '%% -> $' || s.client_price || ')'), ',
            ') services
                    from public.appointment_service s
                    group by s.appointment_id
                ) srv
                    on b.id = srv.appointment_id
                inner join public.rpt_user sc
                    on b.client_id = sc.client_id
                inner join public.rpt_user ss
                    on b.stylist_id = ss.stylist_id
                left join public.stylist s
                    on b.stylist_id = s.id
                left join public.salon sl
                    on sl.id = s.salon_id
                left join public.rpt_user cc
                    on b.created_by_id = cc.id
                 left join (
                    select distinct h.appointment_id
                    from public.appointment_status_history h
                        inner join public."user" bot
                            on h.updated_by_id = bot.id
                    where h.status = 'checked_out'
                        and bot.email = 'auto_appointment_updater@madebeauty.com'
                 ) auto_checkout
                    on auto_checkout.appointment_id = b.id
            window previous_booking as (partition by b.client_id order by b.datetime_start_at)
            ;


            drop view if exists public.rpt_distribution_stylists_per_clients cascade;

            create or replace view public.rpt_distribution_stylists_per_clients as
            select 
                a.stylists_count, 
                substring( '   ' || a.stylists_count::varchar from '...$') s_stylists_count, 
                count( distinct a.client_id) client_count,
                current_timestamp datetime,
                'booking'::text AS link_type
            from (
                select c.client_id, 
                    count( distinct t.stylist_id) stylists_count
                from public.rpt_user c
                    left join public.appointment t
                        on t.client_id = c.client_id
                    left join     public.rpt_user s
                        on t.stylist_id = s.stylist_id
                where c.is_client = 1
                group by c.client_id
                ) a
            group by a.stylists_count
            union
            select 
                a.stylists_count, 
                substring( '   ' || a.stylists_count::varchar from '...$') s_stylists_count, 
                count( distinct a.client_id) client_count,
                current_timestamp datetime,
                'preferred stylist'::text AS link_type
            from (
                select c.client_id, 
                    count( distinct p.stylist_id) stylists_count
                from public.rpt_user c
                    left join public.preferred_stylist p
                        on p.client_id = c.client_id and p.deleted_at is null
                    left join     public.rpt_user s
                        on p.stylist_id = s.stylist_id
                where c.is_client = 1
                group by c.client_id
                ) a
            group by a.stylists_count
            ;


            drop view if exists public.rpt_distribution_clients_per_stylists cascade;

            create or replace view public.rpt_distribution_clients_per_stylists as
            select 
                current_timestamp datetime,
                'booking' link_type,
                a.clients_count, 
                substring( '   ' || a.clients_count::varchar from '...$') s_clients_count, 
                count( distinct a.stylist_id) stylist_count
            from (
                select count( distinct t.client_id) clients_count, s.stylist_id
                from public.rpt_user s
                    left join public.appointment t
                        on s.stylist_id = t.stylist_id 
                    left join public.rpt_user c
                        on t.client_id = c.client_id
                where s.is_stylist = 1
                    and s.is_partial_stylist = 0
                group by s.stylist_id
                ) a
            group by a.clients_count
            union all
            select 
                current_timestamp datetime,
                'preferred stylist' link_type,
                a.clients_count, 
                substring( '   ' || a.clients_count::varchar from '...$') s_clients_count, 
                count( distinct a.stylist_id) stylist_count
            from (
                select count( distinct t.client_id) clients_count, us.stylist_id
                from public.rpt_user us
                    left join public.preferred_stylist t
                        on t.stylist_id = us.stylist_id and t.deleted_at is null
                    left join public.rpt_user c
                        on t.client_id = c.client_id
                where us.is_stylist = 1
                    and us.is_partial_stylist = 0
                group by us.stylist_id
                ) a
            group by a.clients_count
            ;


            drop view if exists public.rpt_distribution_pareto_stylist_client cascade;

            create or replace view public.rpt_distribution_pareto_stylist_client as
            SELECT 
                datetime, 
                clients_percent, 
                stylist_percent,
                date '2018-01-01' + round( stylist_percent*100)::integer fake_date
            FROM (
                select 
                    current_timestamp datetime,
                    (sum( a.clients_count) over ( order by a.clients_count desc, a.stylist_id))/
                        (sum( a.clients_count) over ( partition by a.g))::float clients_percent, 
                    (count( a.stylist_id) over ( order by a.clients_count desc, a.stylist_id))/
                        (count( a.stylist_id) over ( partition by a.g))::float stylist_percent
                from (
                    select 
                        count( distinct t.client_id) clients_count, 
                        t.stylist_id, 
                        1 g
                    from public.appointment t
                        inner join public.rpt_user uc
                            on t.client_id = uc.client_id
                        inner join public.rpt_user us
                            on t.stylist_id = us.stylist_id
                    group by t.stylist_id
                    ) a
                union 
                select current_timestamp, .0, .0
                ) T
            ;


            drop view if exists public.rpt_booking_h cascade;

            create or replace view public.rpt_booking_h as
            select
                weekly.dt,
                weekly.weekly_stylists,
                weekly.weekly_bookings,
                case weekly.weekly_stylists
                    when 0 then null
                    else weekly.weekly_bookings / weekly.weekly_stylists 
                    end weekly_bookings_per_stylist,
                weekly_revenue.weekly_avg_stylist_revenue,
                weekly_revenue.weekly_median_stylist_revenue,
                monthly.monthly_stylists,
                monthly.monthly_bookings,
                case monthly.monthly_stylists
                    when 0 then null
                    else monthly.monthly_bookings / monthly.monthly_stylists 
                    end monthly_bookings_per_stylist,
                case monthly.monthly_stylists
                    when 0 then null
                    else monthly.monthly_revenue / monthly.monthly_stylists 
                    end monthly_avg_stylist_revenue,
                sum(daily.daily_bookings) over (partition by daily.dt3) daily_bookings,
                sum(daily.daily_bookings) over (order by daily.dt3) rolling_daily_bookings,
                sum(daily.daily_revenue) over (partition by daily.dt3) daily_revenue,
                sum(daily.daily_revenue) over (order by daily.dt3) rolling_daily_revenue
            from (
                    select
                        d.dt,
                        count( distinct b.stylist_id) as weekly_stylists,
                        count( b.id) as weekly_bookings
                    from
                        public.rpt_dates d
                        left join public.rpt_booking b
                            on b.dt_start_at between d.dt_week_ago and d.dt
                    where d.is_future = false
                    group by d.dt
                ) weekly
                inner join (
                    select
                            d.dt dt2,
                            count( distinct b.stylist_id) as monthly_stylists,
                            count( distinct b.id) as monthly_bookings,
                            sum( b.grand_total) as monthly_revenue
                        from
                            public.rpt_dates d
                            left join public.rpt_booking b
                                on b.dt_start_at between d.dt_month_ago and d.dt
                        where d.is_future = false
                        group by d.dt
                ) monthly
                    on weekly.dt = monthly.dt2
                inner join (
                    select
                        r.dt,
                        avg( r.stylist_revenue) weekly_avg_stylist_revenue,
                        percentile_cont( .5) within group (order by r.stylist_revenue) as weekly_median_stylist_revenue
                    from (
                        select 
                            d.dt, 
                            b.stylist_id    ,
                            sum( b.grand_total)::float as stylist_revenue
                        from
                            public.rpt_dates d
                            left join public.rpt_booking b
                                on b.dt_start_at between d.dt_week_ago and d.dt
                        where d.is_future = false
                        group by d.dt, b.stylist_id
                        ) r
                    group by r.dt
                ) weekly_revenue
                    on weekly.dt = weekly_revenue.dt
                inner join (
                    select
                        d.dt dt3,
                        count( distinct b.stylist_id) as daily_stylists,
                        count( b.id) as daily_bookings,
                        sum( b.grand_total) as daily_revenue
                    from
                        public.rpt_dates d
                        left join public.rpt_booking b
                            on b.dt_start_at = d.dt
                    where d.is_future = false
                    group by d.dt
                ) daily
                    on weekly.dt = daily.dt3
            ;


            drop view if exists public.rpt_client_funnel;

            create or replace view public.rpt_client_funnel as
            select 
                dt.dt,
                u.id,
                u.client_id,
                case 
                    when dt.dt >= date_trunc( 'day', b.re_checked_out_at)
                    then '6_re_checked_out'
                    when dt.dt >= date_trunc( 'day', b.checked_out_at)
                    then '5_checked_out'
                    when dt.dt >= date_trunc( 'day', b.rebooked_at)
                    then '4_rebooked'
                    when dt.dt >= date_trunc( 'day', b.booked_at)
                    then '3_booked'
                    when dt.dt >= date_trunc( 'day', p.saved_at) and p.is_partial_stylist = 1
                    then '2_saved_partial_stylist'
                    when dt.dt >= date_trunc( 'day', p.saved_at) and p.is_partial_stylist = 0
                    then '2_saved_stylist'
                    else '1_registered'
                    end client_status,
                u.date_joined,
                p.saved_at,
                b.booked_at,
                b.rebooked_at,
                b.checked_out_at
            from public.rpt_user u
                inner join public.rpt_dates dt
                    on u.dt_joined <= dt.dt and dt.is_future = false
                left join (
                    -- bookings - 1st and 2nd dates if any
                    select
                        aa.client_id,
                        min( aa.booked_at) booked_at,
                        min( aa.rebooked_at) rebooked_at,
                        min( aa.checked_out_at) checked_out_at,
                        min( aa.re_checked_out_at) re_checked_out_at
                    from (
                        select
                            a.client_id,
                            a.created_at booked_at,
                            lag( a.created_at, 1, null) over (partition by a.client_id order by a.created_at desc) rebooked_at,
                            case a.status 
                                when 'checked_out' 
                                then a.datetime_start_at 
                                else null end checked_out_at,
                            case a.status 
                                when 'checked_out' 
                                then lag( a.datetime_start_at, 1, null) over (partition by a.client_id, a.status order by a.created_at desc) 
                                else null end re_checked_out_at
                        from public.rpt_booking a
                        where a.client_id is not null
                        ) aa
                    group by aa.client_id
                ) b
                    on u.client_id = b.client_id
                left join (
                    -- preferred stylist selected
                    select p0.client_id,
                        min( uu.is_partial_stylist) is_partial_stylist,
                        min( p0.created_at) saved_at
                    from public.preferred_stylist p0
                        inner join public.rpt_user uu
                        on p0.stylist_id = uu.stylist_id
                    group by p0.client_id
                ) p
                    on u.client_id = p.client_id
            where u.is_client = 1
                and u.is_stylist = 0
            ;


            drop view if exists public.rpt_stylist_funnel;

            create or replace view public.rpt_stylist_funnel as
            select 
                dt.dt,
                u.id,
                u.stylist_id,
                case when dt.dt >= date_trunc( 'day', b.re_checked_out_10_at)
                    then '6_re_checked_out_10'
                     when dt.dt >= date_trunc( 'day', b.re_checked_out_at)
                    then '6_re_checked_out'
                    when dt.dt >= date_trunc( 'day', b.checked_out_at)
                    then '6_checked_out'
                    when dt.dt >= date_trunc( 'day', b.rebooked_10_at)
                    then '5_rebooked_10'
                    when dt.dt >= date_trunc( 'day', b.rebooked_at)
                    then '5_rebooked'
                    when dt.dt >= date_trunc( 'day', b.booked_at)
                    then '5_booked'
                    when dt.dt >= date_trunc( 'day', p.saved_at)
                    then '4_saved'
                    when dt.dt >= date_trunc( 'day', ii.invitation_accepted)
                    then '3_invitation_accepted'
                    when dt.dt >= date_trunc( 'day', ii.invitation_sent)
                    then '3_invitation_sent'
                    when dt.dt >= u.dt_joined 
                        and u.is_profile_bookable
                    then '2_bookable'
                    else '1_registered'
                    end stylist_status
            from public.rpt_user u
                inner join public.rpt_dates dt
                    on u.dt_joined <= dt.dt and dt.is_future = false
                left join (
                    -- bookings - 1st, 2nd and 10th dates if any
                    select
                        aa.stylist_id,
                        min( aa.booked_at) booked_at,
                        min( aa.rebooked_at) rebooked_at,
                        min( aa.rebooked_10_at) rebooked_10_at,
                        min( aa.checked_out_at) checked_out_at,
                        min( aa.re_checked_out_at) re_checked_out_at,
                        min( aa.re_checked_out_10_at) re_checked_out_10_at
                    from (
                        select
                            a.stylist_id,
                            a.created_at booked_at,
                            lag( a.created_at, 1, null) 
                                over (partition by a.stylist_id order by a.created_at desc) rebooked_at,
                            lag( a.created_at, 10, null) 
                                over (partition by a.stylist_id order by a.created_at desc) rebooked_10_at,
                            case a.status when 'checked_out' then a.datetime_start_at else null end checked_out_at,
                            lag( case a.status when 'checked_out' then a.datetime_start_at else null end, 1, null) 
                                over (partition by a.stylist_id order by a.datetime_start_at desc) re_checked_out_at,
                            lag( case a.status when 'checked_out' then a.datetime_start_at else null end, 10, null) 
                                over (partition by a.stylist_id order by a.datetime_start_at desc) re_checked_out_10_at
                        from public.rpt_booking a
                        where a.client_id is not null
                        ) aa
                    group by aa.stylist_id
                ) b
                    on u.stylist_id = b.stylist_id
                left join (
                    --invitations sent
                    select i.stylist_id,
                        min( i.created_at) invitation_sent,
                        min( i.accepted_at) invitation_accepted
                    from public.invitation i
                    group by i.stylist_id
                ) ii 
                    on ii.stylist_id = u.stylist_id
                left join (
                    -- stylist saved by real client (non-staff and non-stylist)
                    select p0.stylist_id,
                        min( p0.created_at) saved_at
                    from public.preferred_stylist p0
                        inner join public.rpt_user uu
                        on p0.client_id = uu.client_id 
                    where p0.deleted_at is null
                        and uu.is_staff = 0 
                        and uu.is_stylist = 0
                    group by p0.stylist_id
                ) p
                    on u.stylist_id = p.stylist_id
            where u.is_stylist = 1 
                and u.is_partial_stylist = 0
            order by 1
            ;

        end
        $do$;
        '''
    )


def backward(app, schema_editor):
    schema_editor.execute(
        '''
        DO
        $do$
        begin

            drop view if exists public.rpt_client_funnel cascade;
            drop view if exists public.rpt_stylist_funnel cascade;

            drop view if exists public.rpt_missed_views;


            create or replace view public.rpt_missed_views as
            select 
                'ebdb' table_catalog,
                'public' table_schema, 
                unnest(array[
                    'rpt_users_h',
                    'rpt_stylist',
                    'rpt_booking',
                    'rpt_distribution_stylists_per_clients',
                    'rpt_booking_h',
                    'rpt_distribution_clients_per_stylists',
                    'rpt_distribution_pareto_stylist_client',
                    'rpt_appointment_service',
                    'rpt_dates']) table_name
            except
            select 
                table_catalog,
                table_schema,
                table_name
            from information_schema.tables
            where table_type = 'VIEW'
            ;
                    
    
            drop view if exists public.rpt_all_users cascade;
    
            create or replace view public.rpt_all_users as
            select u.id, 
                u.is_active, 
                ('staff' = ANY( u.role) or u.is_staff)::int is_staff, 
                ((c.id is not null 
                    and c.id in (
                        select p.client_id 
                        from public.preferred_stylist p
                            inner join public.stylist s2
                                on p.stylist_id = s2.id
                            inner join public."user" u2
                                on s2.user_id =  u2.id
                        where 'staff' = any( u2.role)
                            and p.deleted_at is null
                        )
                    ))::int is_staff_affiliated,
                u.date_joined,
                date_trunc( 'day', u.date_joined) dt_joined,
                u.last_login,
                ('stylist' = ANY( u.role))::int is_stylist,
                ('stylist' = ANY( u.role) and u.phone is null)::int is_partial_stylist,    
                ('client' = ANY( u.role))::int is_client,
                (inv.created_client_id is not null)::int is_invitation,
                c.id client_id,
                s.id stylist_id,
                u.first_name,
                u.last_name,
                u.phone,
                case when u.email  similar to 'client(-?[0-9a-f]{4}){8}@madebeauty.com' then '' else u.email end email,
                u.role::varchar roles,
                s.instagram_url,
                s.website_url,
                sl."name" salon_name,
                sl.address salon_address,
                (case when u.first_name is null then 0 else 1 end +
                    case when u.last_name is null then 0 else 1 end +
                    case when u.email similar to 'client(-?[0-9a-f]{4}){8}@madebeauty.com' then 0 else 1 end +
                    case when u.phone is null then 0 else 1 end) / 4. client_completeness,
                (case when u.first_name is null then 0 else 1 end +
                    case when u.last_name is null then 0 else 1 end +
                    case when u.email similar to 'client(-?[0-9a-f]{4}){8}@madebeauty.com' then 0 else 1 end +
                    case when u.phone is null then 0 else 1 end +
                    case when s.instagram_url is null then 0 else 1 end +
                    case when s.website_url is null then 0 else 1 end +
                    case when sl.address is null then 0 else 1 end) / 7. stylist_completeness,
                case when u.phone is null then 0 else 1 end is_phone,
                (select count(distinct p3.stylist_id)
                    from public.preferred_stylist p3
                    where p3.client_id = c.id
                        and p3.deleted_at is null) preferred_stylists_count
            from public.user u
                left join (
                    select c.user_id, max( i.created_client_id) created_client_id
                    from public.client c
                        left join public.invitation i
                            on c.id = i.created_client_id
                    group by c.user_id) inv
                on u.id = inv.user_id
                left join public.stylist s
                    on u.id = s.user_id
                left join public.salon sl
                    on s.salon_id = sl.id
                left join public.client c
                    on u.id = c.user_id
            ;
    
    
            drop view if exists public.rpt_user cascade;
    
            create or replace view public.rpt_user as
            select *
            from public.rpt_all_users
            where is_staff::int = 0
            ;
    
    
            drop view if exists public.rpt_users_h cascade;
    
            create or replace view public.rpt_users_h as
            select distinct
                dt.dt,
                date_trunc( 'week', dt.dt) "week",
                sum( u.is_client) over (partition by dt.dt) clients,
                sum( u.is_stylist) over (partition by dt.dt) stylists,
                sum( u.is_client) over (order by dt.dt) rolling_clients,
                sum( u.is_stylist) over (order by dt.dt) rolling_stylists,
                sum( u.is_phone) over (partition by dt.dt) phones,
                sum( u.is_phone) over (order by dt.dt) rolling_phones,
                sum( case u.client_completeness when 1 then 1 else 0 end) over (partition by dt.dt) completed_clients,
                sum( case u.client_completeness when 1 then 1 else 0 end) over (order by dt.dt) rolling_completed_clients
            from rpt_dates dt
                left join public.rpt_user u
                    on u.dt_joined = dt.dt
            where 
                u.is_staff = 0
            ;
    
    
            drop view if exists public.rpt_stylist cascade;
    
            create or replace view public.rpt_stylist as
            select 
                st.id stylist_id,
                coalesce( srv.stylist_services_count, 0) stylist_services_count,
                srv.avg_regular_price,
                coalesce( wd.weekday_discounts_count, 0)::int weekday_discounts_count,
                case when coalesce( wd.weekday_discounts_count, 0) > 0 
                    then 1 else 0 
                    end is_daily_discount,
                coalesce( wd.avg_weekday_discount, 0) avg_weekday_discount,
                (0 < any( st.rebook_discounts))::int is_loyalty_discount,
                case when 0 = all( st.rebook_discounts)
                    then 0::float
                    else
                    (select avg( nullif( discount, 0)) from unnest( st.rebook_discounts) discount)
                    end avg_loyalty_discount,
                (st.rebook_within_1_week_discount_percent > 0)::int is_first_week_discount,
                st.first_time_book_discount_percent,
                st.rebook_within_1_week_discount_percent,
                (st.maximum_discount > 0 and st.is_maximum_discount_enabled)::int is_maximum_discount_enabled,
                case when not st.is_maximum_discount_enabled 
                    then null else st.maximum_discount 
                    end maximum_discount,
                (0 = all( st.rebook_discounts || 
                    array[
                        st.is_maximum_discount_enabled::int4,
                        coalesce( wd.weekday_discounts_count, 0)::int4
                        ]))::int no_discount_count
            from (
                    select *,
                        array[ rebook_within_1_week_discount_percent,
                            rebook_within_2_weeks_discount_percent,
                            rebook_within_3_weeks_discount_percent, 
                            rebook_within_4_weeks_discount_percent
                            ] rebook_discounts
                    from public.stylist
                ) st
                left join (
                    select ss.stylist_id, 
                        count( ss.id) stylist_services_count, 
                        avg( ss.regular_price) avg_regular_price
                    from public.stylist_service ss
                    where ss.is_enabled = true and ss.deleted_at is null
                    group by ss.stylist_id
                ) srv
                    on st.id = srv.stylist_id
                left join (
                    select swd.stylist_id, 
                        count( swd.id) weekday_discounts_count,
                        avg( swd.discount_percent) avg_weekday_discount
                    from public.stylist_weekday_discount swd
                    where swd.discount_percent > 0
                    group by swd.stylist_id
                ) wd
                    on st.id = wd.stylist_id
                inner join public.rpt_user ss
                    on st.id = ss.stylist_id
            ;
    
    
            drop view if exists public.rpt_booking cascade;
    
            create or replace view public.rpt_booking as
            select
                b.id,
                b.datetime_start_at,
                date_trunc( 'day', b.datetime_start_at) dt_start_at,
                to_char( b.datetime_start_at, 'YYYY-MM-DD HH24:MI') datetime_start_at_,
                b.created_at,
                to_char( b.created_at, 'YYYY-MM-DD HH24:MI') created_at_,
                case when current_timestamp < date_trunc('day', b.datetime_start_at)::date + interval '1 week' - interval '1 day'  
                    then 1 else null 
                    end :: integer is_last_week,
                case when current_timestamp < date_trunc('day', b.datetime_start_at)::date + interval '1 month' - interval '1 day'  
                    then 1 else null 
                    end :: integer is_last_month,
                b.stylist_id,
                b.status,
                (b.status = 'checked_out')::int is_checked_out,
                (b.status in ( 'cancelled_by_client', 'cancelled_by_stylist'))::int is_cancelled,
                b.grand_total,
                srv.is_discount,
                case when srv.discount_amount > 0 
                    then srv.discount_amount else null 
                    end discount_amount,
                lag( b.datetime_start_at, 1, b.datetime_start_at - interval '100 years') over previous_booking previous_booking_date,
                (b.datetime_start_at - interval '3 months' <
                    lag( b.datetime_start_at, 1, b.datetime_start_at - interval '100 years') over previous_booking)::int rebooking_3_months,
                (b.datetime_start_at - interval '6 months' <
                    lag( b.datetime_start_at, 1, b.datetime_start_at - interval '100 years') over previous_booking)::int rebooking_6_months,
                srv.services_count,
                (srv.services_count >= 2)::int is_two_and_more_services,
                trim(b.client_first_name || ' ' || b.client_last_name) client,
                trim(cc.first_name || ' ' || cc.last_name) client2,
                b.client_phone,
                b.client_id,
                trim(ss.first_name || ' ' || ss.last_name) stylist,
                ss.phone stylist_phone,
                sl."name" salon,
                srv.services,
                (auto_checkout.appointment_id is not null)::int is_auto_checkout
            from public.appointment b
                left join (
                    select s.appointment_id,
                        sum( s.regular_price - s.client_price) discount_amount,
                        max(( s.applied_discount is not null)::int) is_discount,
                        count( s.id) services_count,
                        array_to_string( array_agg( s.service_name || ' ($' || s.regular_price || 
                            ' -' || s.discount_percentage || '%% -> $' || s.client_price || ')'), ',
            ') services
                    from public.appointment_service s
                    group by s.appointment_id
                ) srv
                    on b.id = srv.appointment_id
                inner join public.rpt_user sc
                    on b.client_id = sc.client_id
                inner join public.rpt_user ss
                    on b.stylist_id = ss.stylist_id
                left join public.stylist s
                    on b.stylist_id = s.id
                left join public.salon sl
                    on sl.id = s.salon_id
                left join public.rpt_user cc
                     on b.created_by_id = cc.id
                 left join (
                     select distinct h.appointment_id
                     from public.appointment_status_history h
                         inner join public."user" bot
                             on h.updated_by_id = bot.id
                     where h.status = 'checked_out'
                         and bot.email = 'auto_appointment_updater@madebeauty.com'
                 ) auto_checkout
                     on auto_checkout.appointment_id = b.id
            window previous_booking as (partition by b.client_id order by b.datetime_start_at)
            ;
    
    
            drop view if exists public.rpt_booking_h cascade;
    
            create or replace view public.rpt_booking_h as
            select 
                weekly.dt,
                weekly.weekly_stylists,
                weekly.weekly_bookings,
                case weekly.weekly_stylists 
                    when 0 then null 
                    else weekly.weekly_bookings / weekly.weekly_stylists 
                    end weekly_bookings_per_stylist,
                weekly_revenue.weekly_avg_stylist_revenue,
                weekly_revenue.weekly_median_stylist_revenue,
                monthly.monthly_stylists,
                monthly.monthly_bookings,
                case monthly.monthly_stylists
                    when 0 then null
                    else monthly.monthly_bookings / monthly.monthly_stylists 
                    end monthly_bookings_per_stylist,
                case monthly.monthly_stylists
                    when 0 then null
                    else monthly.monthly_revenue / monthly.monthly_stylists 
                    end monthly_avg_stylist_revenue,
                sum(daily.daily_bookings) over (partition by daily.dt3) daily_bookings,
                sum(daily.daily_bookings) over (order by daily.dt3) rolling_daily_bookings,
                sum(daily.daily_revenue) over (partition by daily.dt3) daily_revenue,
                sum(daily.daily_revenue) over (order by daily.dt3) rolling_daily_revenue
            from (
                    select
                        d.dt,
                        count( distinct b.stylist_id) as weekly_stylists,
                        count( b.id) as weekly_bookings
                    from
                        public.rpt_dates d
                        left join public.rpt_booking b
                            on b.dt_start_at between d.dt_week_ago and d.dt
                    where d.is_future = false
                    group by d.dt
                ) weekly
                inner join (
                    select
                            d.dt dt2,
                            count( distinct b.stylist_id) as monthly_stylists,
                            count( distinct b.id) as monthly_bookings,
                            sum( b.grand_total) as monthly_revenue
                        from
                            public.rpt_dates d
                            left join public.rpt_booking b
                                on b.dt_start_at between d.dt_month_ago and d.dt
                        where d.is_future = false
                        group by d.dt
                ) monthly
                    on weekly.dt = monthly.dt2
                inner join (
                    select
                        r.dt,
                        avg( r.stylist_revenue) weekly_avg_stylist_revenue,
                        percentile_cont( .5) within group (order by r.stylist_revenue) as weekly_median_stylist_revenue
                    from (
                        select 
                            d.dt, 
                            b.stylist_id    ,
                            sum( b.grand_total)::float as stylist_revenue
                        from
                            public.rpt_dates d
                            left join public.rpt_booking b
                                on b.dt_start_at between d.dt_week_ago and d.dt
                        where d.is_future = false
                        group by d.dt, b.stylist_id
                        ) r
                    group by r.dt
                ) weekly_revenue
                    on weekly.dt = weekly_revenue.dt
                inner join (
                    select
                        d.dt dt3,
                        count( distinct b.stylist_id) as daily_stylists,
                        count( b.id) as daily_bookings,
                        sum( b.grand_total) as daily_revenue
                    from
                        public.rpt_dates d
                        left join public.rpt_booking b
                            on b.dt_start_at = d.dt
                    where d.is_future = false
                    group by d.dt
                ) daily
                    on weekly.dt = daily.dt3
            ;
    
    
            drop view if exists public.rpt_appointment_service cascade;
    
            create or replace view public.rpt_appointment_service as
            select 
                aps.service_uuid,
                a.datetime_start_at,
                aps.regular_price,
                aps.client_price,
                aps.calculated_price
            from public.appointment_service aps
                inner join public.appointment a
                on aps.appointment_id = a.id
            ;
    
    
            drop view if exists public.rpt_distribution_clients_per_stylists cascade;
    
            create or replace view public.rpt_distribution_clients_per_stylists as
            select 
                current_timestamp datetime,
                'booking' link_type,
                a.clients_count, 
                substring( '   ' || a.clients_count::varchar from '...$') s_clients_count, 
                count( distinct a.stylist_id) stylist_count
            from (
                select count( distinct t.client_id) clients_count, s.stylist_id
                from public.rpt_user s
                    left join public.appointment t
                        on s.stylist_id = t.stylist_id 
                    left join public.rpt_user c
                        on t.client_id = c.client_id
                where s.is_stylist = 1
                group by s.stylist_id
                ) a
            group by a.clients_count
            union all
            select 
                current_timestamp datetime,
                'preferred stylist' link_type,
                a.clients_count, 
                substring( '   ' || a.clients_count::varchar from '...$') s_clients_count, 
                count( distinct a.stylist_id) stylist_count
            from (
                select count( distinct t.client_id) clients_count, us.stylist_id
                from public.rpt_user us
                    left join public.preferred_stylist t
                        on t.stylist_id = us.stylist_id and t.deleted_at is null
                    left join public.rpt_user c
                        on t.client_id = c.client_id
                where us.is_stylist = 1
                group by us.stylist_id
                ) a
            group by a.clients_count;
    
    
            drop view if exists public.rpt_distribution_pareto_stylist_client cascade;
    
            create or replace view public.rpt_distribution_pareto_stylist_client as
            SELECT 
                datetime, 
                link_type,
                clients_percent, 
                stylist_percent,
                date '2018-01-01' + round( stylist_percent*100)::integer fake_date
            FROM (
                select 
                    current_timestamp datetime,
                    link_type,
                    (sum( a.clients_count) over ( order by a.clients_count desc, a.stylist_id))/
                        (sum( a.clients_count) over ( partition by a.g))::float clients_percent, 
                    (count( a.stylist_id) over ( order by a.clients_count desc, a.stylist_id))/
                        (count( a.stylist_id) over ( partition by a.g))::float stylist_percent
                from (
                    select 
                        'booking' link_type,
                        count( distinct t.client_id) clients_count, 
                        us.stylist_id, 
                        1 g
                    from public.rpt_user us 
                        left join public.rpt_booking t
                            on t.stylist_id = us.stylist_id 
                        left join public.rpt_user uc
                            on t.client_id = uc.client_id
                    where 
                        us.is_stylist = 1
                        and us.is_partial_stylist = 0
                    group by us.stylist_id
                    union all
                    select 
                        'preferred stylist' link_type,
                        count( distinct t.client_id) clients_count, 
                        us.stylist_id, 
                        1 g
                    from public.rpt_user us
                        left join public.preferred_stylist t
                            on t.stylist_id = us.stylist_id and t.deleted_at is null
                        left join public.rpt_user uc
                            on t.client_id = uc.client_id
                    where 
                        us.is_stylist = 1
                        and us.is_partial_stylist = 0
                    group by us.stylist_id        
                    ) a
                union 
                select current_timestamp, 'booking', .0, .0
                union 
                select current_timestamp, 'preferred stylist', .0, .0
                ) T
                ;
    
        
            drop view if exists public.rpt_distribution_stylists_per_clients cascade;
    
            create or replace view public.rpt_distribution_stylists_per_clients as
            select 
                a.stylists_count, 
                substring( '   ' || a.stylists_count::varchar from '...$') s_stylists_count, 
                count( distinct a.client_id) client_count,
                current_timestamp datetime,
                'booking'::text AS link_type
            from (
                select c.client_id, 
                    count( distinct t.stylist_id) stylists_count
                from public.rpt_user c
                    left join public.appointment t
                        on t.client_id = c.client_id
                    left join     public.rpt_user s
                        on t.stylist_id = s.stylist_id
                where c.is_client = 1
                group by c.client_id
                ) a
            group by a.stylists_count
            union
            select 
                a.stylists_count, 
                substring( '   ' || a.stylists_count::varchar from '...$') s_stylists_count, 
                count( distinct a.client_id) client_count,
                current_timestamp datetime,
                'preferred stylist'::text AS link_type
            from (
                select c.client_id, 
                    count( distinct p.stylist_id) stylists_count
                from public.rpt_user c
                    left join public.preferred_stylist p
                        on p.client_id = c.client_id and p.deleted_at is null
                    left join     public.rpt_user s
                        on p.stylist_id = s.stylist_id
                where c.is_client = 1
                group by c.client_id
                ) a
            group by a.stylists_count
            ;
    
    
        end
        $do$;
        '''
    )


class Migration(migrations.Migration):
    dependencies = [
        ('appointment', '0035_auto_20181122_0352'),
        ('client', '0025_auto_20181126_0400'),
        ('core', '0039_auto_20181115_1245'),
        ('notifications', '0007_auto_20181115_1213'),
        ('salon', '0071_stylist_deactivated_at')
    ]

    operations = [
        migrations.RunPython(forward, backward)
    ]
