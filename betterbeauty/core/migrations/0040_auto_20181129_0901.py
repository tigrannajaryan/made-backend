# Generated by Django 2.1 on 2018-11-29 14:01

from django.db import migrations


def forward(app, schema_editor):
    schema_editor.execute(
        """
        DO
        $do$
        begin

	        --ebdb.public.rpt_appointment_service
            drop view if exists public.rpt_appointment_service cascade;

            create or replace view public.rpt_appointment_service as
            select 
                aps.service_uuid,
                a.datetime_start_at,
                aps.regular_price,
                aps.client_price,
                aps.calculated_price
            from public.appointment_service aps
                inner join public.appointment a
                on aps.appointment_id = a.id
            ;


	        --ebdb.public.rpt_dates


	        --ebdb.public.rpt_missed_views
            drop view if exists public.rpt_missed_views;

            create or replace view public.rpt_missed_views as
            /*
             * Test presense of necessary reporting views
             * 
             * Usage:
             * 
             * select * from public.rpt_missed_views;
             * 
             * if this query fails - test failed,
             * if any rows returned - test failed
             * 		every returned row describes missed view
             * 		and should be outputed as explaination
             * 		of failure
             * 
             */
            select 
                'ebdb' table_catalog,
                'public' table_schema, 
                unnest(array[
                    'rpt_client_funnel',
                    'rpt_stylist_funnel',
                    'rpt_distribution_stylists_per_clients',
                    'rpt_distribution_clients_per_stylists',
                    'rpt_distribution_pareto_stylist_client',
                    'rpt_appointment_service',
                    'rpt_booking_h',
                    'rpt_booking',
                    'rpt_stylist',
                    'rpt_users_h',
                    'rpt_user',
                    'rpt_all_users',
                    'rpt_dates']) table_name
            except
            select 
                table_catalog,
                table_schema,
                table_name
            from information_schema.tables
            where table_type = 'VIEW'
                and  table_name like 'rpt%'
            ;


	        --ebdb.public.rpt_all_users
            drop view if exists public.rpt_all_users cascade;

            create or replace view public.rpt_all_users as
            select u.id, 
                u.is_active, 
                ('staff' = ANY( u.role) or u.is_staff)::int is_staff, 
                ((c.id is not null 
                    and c.id in (
                        select p.client_id 
                        from public.preferred_stylist p
                            inner join public.stylist s2
                                on p.stylist_id = s2.id
                            inner join public."user" u2
                                on s2.user_id =  u2.id
                        where 'staff' = any( u2.role)
                            and p.deleted_at is null
                        )
                    ))::int is_staff_affiliated,
                u.date_joined,
                date_trunc( 'day', u.date_joined) dt_joined,
                u.last_login,
                ('stylist' = ANY( u.role) and u.phone is not null)::int is_stylist,
                ('stylist' = ANY( u.role) and u.phone is null)::int is_partial_stylist,	
                ('client' = ANY( u.role))::int is_client,
                (inv.created_client_id is not null)::int is_invitation,
                c.id client_id,
                s.id stylist_id,
                u.first_name,
                u.last_name,
                u.phone,
                case when u.email  similar to '(client|stylist)(-?[0-9a-f]{4}){8}@madebeauty.com' then '' else u.email end email,
                u.role::varchar roles,
                s.instagram_url,
                s.website_url,
                sl."name" salon_name,
                sl.address salon_address,
                (case when coalesce( u.first_name, '') = '' then 0 else 1 end +
                    case when coalesce( u.last_name, '') = '' then 0 else 1 end +
                    case when u.phone is null then 0 else 1 end) / 3. client_completeness,
                (case when coalesce( u.first_name, '') = '' then 0 else 1 end +
                    case when coalesce( u.last_name, '') = '' then 0 else 1 end +
                    case when u.email similar to 'stylist(-?[0-9a-f]{4}){8}@madebeauty.com' then 0 else 1 end +
                    case when u.phone is null then 0 else 1 end +
                    case when s.instagram_url is null then 0 else 1 end +
                    case when s.website_url is null then 0 else 1 end +
                    case when sl.address is null then 0 else 1 end) / 7. stylist_completeness,
                case when u.phone is null then 0 else 1 end is_phone,
                (select count(distinct p3.stylist_id)
                    from public.preferred_stylist p3
                    where p3.client_id = c.id
                        and p3.deleted_at is null) preferred_stylists_count,
                services.service_count,
                working_hours.working_hours_count,
                (u.phone is not null 
                    and coalesce( services.service_count, 0) > 0 
                    and coalesce( working_hours.working_hours_count, 0) > 0) is_profile_bookable
            from public.user u
                left join (
                    -- invitations if any
                    select c.user_id, max( i.created_client_id) created_client_id
                    from public.client c
                        left join public.invitation i
                            on c.id = i.created_client_id
                    group by c.user_id) inv
                on u.id = inv.user_id
                left join public.stylist s
                    on u.id = s.user_id
                left join public.salon sl
                    on s.salon_id = sl.id
                left join public.client c
                    on u.id = c.user_id
                left join (
                    -- count services if any
                    select services.stylist_id, count(services.id) service_count
                    from public.stylist_service services
                    group by services.stylist_id
                ) services
                    on s.id = services.stylist_id
                left join (
                    -- count working hours if any
                    select working_hours.stylist_id, count(working_hours.id) working_hours_count
                    from public.stylist_available_day working_hours
                    where working_hours.is_available = True
                        and working_hours.work_start_at is not null
                        and working_hours.work_end_at is not null
                    group by working_hours.stylist_id
                ) working_hours
                    on s.id = working_hours.stylist_id
            ;

            
	        --ebdb.public.rpt_user
            drop view if exists public.rpt_user cascade;

            create or replace view public.rpt_user as
            select *
            from public.rpt_all_users
            where is_staff = 0
            ;

	        --ebdb.public.rpt_stylist
            drop view if exists public.rpt_stylist cascade;

            create or replace view public.rpt_stylist as
            select 
                st.id stylist_id,
                coalesce( srv.stylist_services_count, 0) stylist_services_count,
                srv.avg_regular_price,
                coalesce( wd.weekday_discounts_count, 0)::int weekday_discounts_count,
                case when coalesce( wd.weekday_discounts_count, 0) > 0 
                    then 1 else 0 
                    end is_daily_discount,
                coalesce( wd.avg_weekday_discount, 0) avg_weekday_discount,
                (0 < any( st.rebook_discounts))::int is_loyalty_discount,
                case when 0 = all( st.rebook_discounts)
                    then 0::float
                    else
                    (select avg( nullif( discount, 0)) from unnest( st.rebook_discounts) discount)
                    end avg_loyalty_discount,
                (st.rebook_within_1_week_discount_percent > 0)::int is_first_week_discount,
                st.first_time_book_discount_percent,
                st.rebook_within_1_week_discount_percent,
                (st.maximum_discount > 0 and st.is_maximum_discount_enabled)::int is_maximum_discount_enabled,
                case when not st.is_maximum_discount_enabled 
                    then null else st.maximum_discount 
                    end maximum_discount,
                (0 = all( st.rebook_discounts || 
                    array[
                        st.is_maximum_discount_enabled::int4,
                        coalesce( wd.weekday_discounts_count, 0)::int4
                        ]))::int no_discount_count
            from (
                    select *,
                        array[ rebook_within_1_week_discount_percent,
                            rebook_within_2_weeks_discount_percent,
                            rebook_within_3_weeks_discount_percent, 
                            rebook_within_4_weeks_discount_percent
                            ] rebook_discounts
                    from public.stylist
                ) st
                left join (
                    select ss.stylist_id, 
                        count( ss.id) stylist_services_count, 
                        avg( ss.regular_price) avg_regular_price
                    from public.stylist_service ss
                    where ss.is_enabled = true and ss.deleted_at is null
                    group by ss.stylist_id
                ) srv
                    on st.id = srv.stylist_id
                left join (
                    select swd.stylist_id, 
                        count( swd.id) weekday_discounts_count,
                        avg( swd.discount_percent) avg_weekday_discount
                    from public.stylist_weekday_discount swd
                    where swd.discount_percent > 0
                    group by swd.stylist_id
                ) wd
                    on st.id = wd.stylist_id
                inner join public.rpt_user ss
                    on st.id = ss.stylist_id and ss.is_partial_stylist = 0
            ;


            
	        --ebdb.public.rpt_users_h
            drop view if exists public.rpt_users_h cascade;
            
            create or replace view public.rpt_users_h as
            select distinct
                dt.dt,
                date_trunc( 'week', dt.dt) "week",
                sum( coalesce( u.is_client, 0)) over (partition by dt.dt) clients,
                sum( coalesce( u.is_stylist, 0)) over (partition by dt.dt) stylists,
                sum( coalesce( u.is_client, 0)) over (order by dt.dt) rolling_clients,
                sum( coalesce( u.is_stylist, 0)) over (order by dt.dt) rolling_stylists,
                sum( coalesce( u.is_phone, 0)) over (partition by dt.dt) phones,
                sum( coalesce( u.is_phone, 0)) over (order by dt.dt) rolling_phones,
                sum( case u.client_completeness when 1 then 1 else 0 end) over (partition by dt.dt) completed_clients,
                sum( case u.client_completeness when 1 then 1 else 0 end) over (order by dt.dt) rolling_completed_clients
            from rpt_dates dt
                left join public.rpt_user u
                    on u.dt_joined = dt.dt and u.is_staff = 0 and u.is_partial_stylist = 0
            ;

            
	        --ebdb.public.rpt_booking
            drop view if exists public.rpt_booking cascade;

            create or replace view public.rpt_booking as
            select
                b.id,
                b.datetime_start_at,
                date_trunc( 'day', b.datetime_start_at) dt_start_at,
                to_char( b.datetime_start_at, 'YYYY-MM-DD HH24:MI') datetime_start_at_,
                b.created_at,
                to_char( b.created_at, 'YYYY-MM-DD HH24:MI') created_at_,
                case when current_timestamp < date_trunc('day', b.datetime_start_at)::date + interval '1 week' - interval '1 day'  
                    then 1 else null 
                    end :: integer is_last_week,
                case when current_timestamp < date_trunc('day', b.datetime_start_at)::date + interval '1 month' - interval '1 day'  
                    then 1 else null 
                    end :: integer is_last_month,
                b.stylist_id,
                b.status,
                (b.status = 'checked_out')::int is_checked_out,
                (b.status in ( 'cancelled_by_client', 'cancelled_by_stylist'))::int is_cancelled,
                b.grand_total,
                srv.is_discount,
                case when srv.discount_amount > 0 
                    then srv.discount_amount else null 
                    end discount_amount,
                lag( b.datetime_start_at, 1, b.datetime_start_at - interval '100 years') over previous_booking previous_booking_date,
                (b.datetime_start_at - interval '3 months' <
                    lag( b.datetime_start_at, 1, b.datetime_start_at - interval '100 years') over previous_booking)::int rebooking_3_months,
                (b.datetime_start_at - interval '6 months' <
                    lag( b.datetime_start_at, 1, b.datetime_start_at - interval '100 years') over previous_booking)::int rebooking_6_months,
                srv.services_count,
                (srv.services_count >= 2)::int is_two_and_more_services,
                b.client_id,
                trim(b.client_first_name || ' ' || b.client_last_name) client,
                trim(cc.first_name || ' ' || cc.last_name) client2,
                b.client_phone,
                trim(ss.first_name || ' ' || ss.last_name) stylist,
                ss.phone stylist_phone,
                sl."name" salon,
                srv.services,
                (auto_checkout.appointment_id is not null)::int is_auto_checkout
            from public.appointment b
                left join (
                    select s.appointment_id,
                        sum( s.regular_price - s.client_price) discount_amount,
                        max(( s.applied_discount is not null)::int) is_discount,
                        count( s.id) services_count,
                        array_to_string( array_agg( s.service_name || ' ($' || s.regular_price || 
                            ' -' || s.discount_percentage || '% -> $' || s.client_price || ')'), ',
            ') services
                    from public.appointment_service s
                    group by s.appointment_id
                ) srv
                    on b.id = srv.appointment_id
                inner join public.rpt_user sc
                    on b.client_id = sc.client_id
                inner join public.rpt_user ss
                    on b.stylist_id = ss.stylist_id
                left join public.stylist s
                    on b.stylist_id = s.id
                left join public.salon sl
                    on sl.id = s.salon_id
                left join public.rpt_user cc
                    on b.created_by_id = cc.id
                 left join (
                    select distinct h.appointment_id
                    from public.appointment_status_history h
                        inner join public."user" bot
                            on h.updated_by_id = bot.id
                    where h.status = 'checked_out'
                        and bot.email = 'auto_appointment_updater@madebeauty.com'
                 ) auto_checkout
                    on auto_checkout.appointment_id = b.id
            window previous_booking as (partition by b.client_id order by b.datetime_start_at)
            ;
            
            
	        --ebdb.public.rpt_distribution_stylists_per_clients
            drop view if exists public.rpt_distribution_stylists_per_clients cascade;

            create or replace view public.rpt_distribution_stylists_per_clients as
            select 
                a.stylists_count, 
                substring( '   ' || a.stylists_count::varchar from '...$') s_stylists_count, 
                count( distinct a.client_id) client_count,
                current_timestamp datetime,
                'booking'::text AS link_type
            from (
                select c.client_id, 
                    count( distinct t.stylist_id) stylists_count
                from public.rpt_user c
                    left join public.appointment t
                        on t.client_id = c.client_id
                    left join 	public.rpt_user s
                        on t.stylist_id = s.stylist_id
                where c.is_client = 1
                group by c.client_id
                ) a
            group by a.stylists_count
            union
            select 
                a.stylists_count, 
                substring( '   ' || a.stylists_count::varchar from '...$') s_stylists_count, 
                count( distinct a.client_id) client_count,
                current_timestamp datetime,
                'preferred stylist'::text AS link_type
            from (
                select c.client_id, 
                    count( distinct p.stylist_id) stylists_count
                from public.rpt_user c
                    left join public.preferred_stylist p
                        on p.client_id = c.client_id and p.deleted_at is null
                    left join 	public.rpt_user s
                        on p.stylist_id = s.stylist_id
                where c.is_client = 1
                group by c.client_id
                ) a
            group by a.stylists_count
            ;
            
            
	        --ebdb.public.rpt_distribution_clients_per_stylists
            drop view if exists public.rpt_distribution_clients_per_stylists cascade;

            create or replace view public.rpt_distribution_clients_per_stylists as
            select 
                current_timestamp datetime,
                'booking' link_type,
                a.clients_count, 
                substring( '   ' || a.clients_count::varchar from '...$') s_clients_count, 
                count( distinct a.stylist_id) stylist_count
            from (
                select count( distinct t.client_id) clients_count, s.stylist_id
                from public.rpt_user s
                    left join public.appointment t
                        on s.stylist_id = t.stylist_id 
                    left join public.rpt_user c
                        on t.client_id = c.client_id
                where s.is_stylist = 1
                    and s.is_partial_stylist = 0
                group by s.stylist_id
                ) a
            group by a.clients_count
            union all
            select 
                current_timestamp datetime,
                'preferred stylist' link_type,
                a.clients_count, 
                substring( '   ' || a.clients_count::varchar from '...$') s_clients_count, 
                count( distinct a.stylist_id) stylist_count
            from (
                select count( distinct t.client_id) clients_count, us.stylist_id
                from public.rpt_user us
                    left join public.preferred_stylist t
                        on t.stylist_id = us.stylist_id and t.deleted_at is null
                    left join public.rpt_user c
                        on t.client_id = c.client_id
                where us.is_stylist = 1
                    and us.is_partial_stylist = 0
                group by us.stylist_id
                ) a
            group by a.clients_count
            ;

            
	        --ebdb.public.rpt_distribution_pareto_stylist_client
            drop view if exists public.rpt_distribution_pareto_stylist_client cascade;

            create or replace view public.rpt_distribution_pareto_stylist_client as
            SELECT 
                datetime, 
                clients_percent, 
                stylist_percent,
                date '2018-01-01' + round( stylist_percent*100)::integer fake_date
            FROM (
                select 
                    current_timestamp datetime,
                    (sum( a.clients_count) over ( order by a.clients_count desc, a.stylist_id))/
                        (sum( a.clients_count) over ( partition by a.g))::float clients_percent, 
                    (count( a.stylist_id) over ( order by a.clients_count desc, a.stylist_id))/
                        (count( a.stylist_id) over ( partition by a.g))::float stylist_percent
                from (
                    select 
                        count( distinct t.client_id) clients_count, 
                        t.stylist_id, 
                        1 g
                    from public.appointment t
                        inner join public.rpt_user uc
                            on t.client_id = uc.client_id
                        inner join public.rpt_user us
                            on t.stylist_id = us.stylist_id
                    group by t.stylist_id
                    ) a
                union 
                select current_timestamp, .0, .0
                ) T
            ;

            
	        --ebdb.public.rpt_booking_h	
            drop view if exists public.rpt_booking_h cascade;

            create or replace view public.rpt_booking_h as
            select 
                weekly.dt,
                weekly.weekly_stylists,
                weekly.weekly_bookings,
                case weekly.weekly_stylists 
                    when 0 then null 
                    else weekly.weekly_bookings / weekly.weekly_stylists 
                    end weekly_bookings_per_stylist,
                weekly_revenue.weekly_avg_stylist_revenue,
                weekly_revenue.weekly_median_stylist_revenue,
                monthly.monthly_stylists,
                monthly.monthly_bookings,
                case monthly.monthly_stylists
                    when 0 then null
                    else monthly.monthly_bookings / monthly.monthly_stylists 
                    end monthly_bookings_per_stylist,
                case monthly.monthly_stylists
                    when 0 then null
                    else monthly.monthly_revenue / monthly.monthly_stylists 
                    end monthly_avg_stylist_revenue,
                sum(daily.daily_bookings) over (partition by daily.dt3) daily_bookings,
                sum(daily.daily_bookings) over (order by daily.dt3) rolling_daily_bookings,
                sum(daily.daily_revenue) over (partition by daily.dt3) daily_revenue,
                sum(daily.daily_revenue) over (order by daily.dt3) rolling_daily_revenue
            from (
                    select
                        d.dt,
                        count( distinct b.stylist_id) as weekly_stylists,
                        count( b.id) as weekly_bookings
                    from
                        public.rpt_dates d
                        left join public.rpt_booking b
                            on b.dt_start_at between d.dt_week_ago and d.dt
                    where d.is_future = false
                    group by d.dt
                ) weekly
                inner join (
                    select
                            d.dt dt2,
                            count( distinct b.stylist_id) as monthly_stylists,
                            count( distinct b.id) as monthly_bookings,
                            sum( b.grand_total) as monthly_revenue
                        from
                            public.rpt_dates d
                            left join public.rpt_booking b
                                on b.dt_start_at between d.dt_month_ago and d.dt
                        where d.is_future = false
                        group by d.dt
                ) monthly
                    on weekly.dt = monthly.dt2
                inner join (
                    select
                        r.dt,
                        avg( r.stylist_revenue) weekly_avg_stylist_revenue,
                        percentile_cont( .5) within group (order by r.stylist_revenue) as weekly_median_stylist_revenue
                    from (
                        select 
                            d.dt, 
                            b.stylist_id	,
                            sum( b.grand_total)::float as stylist_revenue
                        from
                            public.rpt_dates d
                            left join public.rpt_booking b
                                on b.dt_start_at between d.dt_week_ago and d.dt
                        where d.is_future = false
                        group by d.dt, b.stylist_id
                        ) r
                    group by r.dt
                ) weekly_revenue
                    on weekly.dt = weekly_revenue.dt
                inner join (
                    select
                        d.dt dt3,
                        count( distinct b.stylist_id) as daily_stylists,
                        count( b.id) as daily_bookings,
                        sum( b.grand_total) as daily_revenue
                    from
                        public.rpt_dates d
                        left join public.rpt_booking b
                            on b.dt_start_at = d.dt
                    where d.is_future = false
                    group by d.dt
                ) daily
                    on weekly.dt = daily.dt3
            ;

            
	        --ebdb.public.rpt_client_funnel
            drop view if exists public.rpt_client_funnel;
            
            create or replace view public.rpt_client_funnel as
            select 
                dt.dt,
                u.id,
                u.client_id,
                case 
                    when dt.dt >= date_trunc( 'day', b.re_checked_out_at)
                    then '6_re_checked_out'
                    when dt.dt >= date_trunc( 'day', b.checked_out_at)
                    then '5_checked_out'
                    when dt.dt >= date_trunc( 'day', b.rebooked_at)
                    then '4_rebooked'
                    when dt.dt >= date_trunc( 'day', b.booked_at)
                    then '3_booked'
                    when dt.dt >= date_trunc( 'day', p.saved_at) and p.is_partial_stylist = 1
                    then '2_saved_partial_stylist'
                    when dt.dt >= date_trunc( 'day', p.saved_at) and p.is_partial_stylist = 0
                    then '2_saved_stylist'
                    else '1_registered'
                    end client_status,
                u.date_joined,
                p.saved_at,
                b.booked_at,
                b.rebooked_at,
                b.checked_out_at
            from public.rpt_user u
                inner join public.rpt_dates dt
                    on u.dt_joined <= dt.dt and dt.is_future = false
                left join (
                    -- bookings - 1st and 2nd dates if any
                    select
                        aa.client_id,
                        min( aa.booked_at) booked_at,
                        min( aa.rebooked_at) rebooked_at,
                        min( aa.checked_out_at) checked_out_at,
                        min( aa.re_checked_out_at) re_checked_out_at
                    from (
                        select
                            a.client_id,
                            a.created_at booked_at,
                            lag( a.created_at, 1, null) over (partition by a.client_id order by a.created_at desc) rebooked_at,
                            case a.status 
                                when 'checked_out' 
                                then a.datetime_start_at 
                                else null end checked_out_at,
                            case a.status 
                                when 'checked_out' 
                                then lag( a.datetime_start_at, 1, null) over (partition by a.client_id, a.status order by a.created_at desc) 
                                else null end re_checked_out_at
            			from public.rpt_booking a
                        where a.client_id is not null
                        ) aa
                    group by aa.client_id
                ) b
                    on u.client_id = b.client_id
                left join (
                    -- preferred stylist selected
                    select p0.client_id,
                        min( uu.is_partial_stylist) is_partial_stylist,
                        min( p0.created_at) saved_at
                    from public.preferred_stylist p0
                        inner join public.rpt_user uu
                        on p0.stylist_id = uu.stylist_id
                    group by p0.client_id
                ) p
                    on u.client_id = p.client_id
            where u.is_client = 1
                and u.is_stylist = 0
            ;
            
            
	        --ebdb.public.rpt_stylist_funnel
            drop view if exists public.rpt_stylist_funnel;
            
            create or replace view public.rpt_stylist_funnel as
            select 
                dt.dt,
                u.id,
                u.stylist_id,
                case when dt.dt >= date_trunc( 'day', b.re_checked_out_10_at)
                    then '6_re_checked_out_10'
                     when dt.dt >= date_trunc( 'day', b.re_checked_out_at)
                    then '6_re_checked_out'
                    when dt.dt >= date_trunc( 'day', b.checked_out_at)
                    then '6_checked_out'
                    when dt.dt >= date_trunc( 'day', b.rebooked_10_at)
                    then '5_rebooked_10'
                    when dt.dt >= date_trunc( 'day', b.rebooked_at)
                    then '5_rebooked'
                    when dt.dt >= date_trunc( 'day', b.booked_at)
                    then '5_booked'
                    when dt.dt >= date_trunc( 'day', p.saved_at)
                    then '4_saved'
                    when dt.dt >= date_trunc( 'day', ii.invitation_accepted)
                    then '3_invitation_accepted'
                    when dt.dt >= date_trunc( 'day', ii.invitation_sent)
                    then '3_invitation_sent'
            		when dt.dt >= u.dt_joined 
            			and u.is_profile_bookable
            		then '2_bookable'
                    else '1_registered'
                    end stylist_status
            from public.rpt_user u
                inner join public.rpt_dates dt
                    on u.dt_joined <= dt.dt and dt.is_future = false
                left join (
                    -- bookings - 1st, 2nd and 10th dates if any
                    select
                        aa.stylist_id,
                        min( aa.booked_at) booked_at,
                        min( aa.rebooked_at) rebooked_at,
                        min( aa.rebooked_10_at) rebooked_10_at,
                        min( aa.checked_out_at) checked_out_at,
                        min( aa.re_checked_out_at) re_checked_out_at,
                        min( aa.re_checked_out_10_at) re_checked_out_10_at
                    from (
                        select
                            a.stylist_id,
                            a.created_at booked_at,
                            lag( a.created_at, 1, null) 
                                over (partition by a.stylist_id order by a.created_at desc) rebooked_at,
                            lag( a.created_at, 10, null) 
                                over (partition by a.stylist_id order by a.created_at desc) rebooked_10_at,
                            case a.status when 'checked_out' then a.datetime_start_at else null end checked_out_at,
                            lag( case a.status when 'checked_out' then a.datetime_start_at else null end, 1, null) 
                                over (partition by a.stylist_id order by a.datetime_start_at desc) re_checked_out_at,
                            lag( case a.status when 'checked_out' then a.datetime_start_at else null end, 10, null) 
                                over (partition by a.stylist_id order by a.datetime_start_at desc) re_checked_out_10_at
            			from public.rpt_booking a
                        where a.client_id is not null
                        ) aa
                    group by aa.stylist_id
                ) b
                    on u.stylist_id = b.stylist_id
                left join (
                    --invitations sent
                    select i.stylist_id,
                        min( i.created_at) invitation_sent,
                        min( i.accepted_at) invitation_accepted
                    from public.invitation i
                    group by i.stylist_id
                ) ii 
                    on ii.stylist_id = u.stylist_id
                left join (
                    -- stylist saved by real client (non-staff and non-stylist)
                    select p0.stylist_id,
                        min( p0.created_at) saved_at
                    from public.preferred_stylist p0
                        inner join public.rpt_user uu
                        on p0.client_id = uu.client_id 
                    where p0.deleted_at is null
                        and uu.is_staff = 0 
                        and uu.is_stylist = 0
                    group by p0.stylist_id
                ) p
                    on u.stylist_id = p.stylist_id
            where u.is_stylist = 1 
                and u.is_partial_stylist = 0
            order by 1
            ;

        end
        $do$;
        """
        )


def backward(app, schema_editor):
    schema_editor.execute(
        """
        DO
        $do$
        begin

	
	        drop view if exists public.rpt_client_funnel cascade;
	        drop view if exists public.rpt_stylist_funnel cascade;

	        drop view if exists public.rpt_missed_views;
	
	        create or replace view public.rpt_missed_views as
	        select 
		        'ebdb' table_catalog,
		        'public' table_schema, 
		        unnest(array[
			        'rpt_users_h',
			        'rpt_stylist',
			        'rpt_booking',
			        'rpt_distribution_stylists_per_clients',
			        'rpt_booking_h',
			        'rpt_distribution_clients_per_stylists',
			        'rpt_distribution_pareto_stylist_client',
			        'rpt_appointment_service',
			        'rpt_dates']) table_name
	        except
	        select 
		        table_catalog,
		        table_schema,
		        table_name
	        from information_schema.tables
	        where table_type = 'VIEW';
	                
	
	        drop view if exists public.rpt_all_users cascade;
	
	        create or replace view public.rpt_all_users as
	        select u.id, 
		        u.is_active, 
		        ('staff' = ANY( u.role) or u.is_staff)::int is_staff, 
		        ((c.id is not null 
			        and c.id in (
				        select p.client_id 
				        from public.preferred_stylist p
					        inner join public.stylist s2
						        on p.stylist_id = s2.id
					        inner join public."user" u2
						        on s2.user_id =  u2.id
				        where 'staff' = any( u2.role)
					        and p.deleted_at is null
				        )
			        ))::int is_staff_affiliated,
		        u.date_joined,
		        date_trunc( 'day', u.date_joined) dt_joined,
		        u.last_login,
		        ('stylist' = ANY( u.role))::int is_stylist,
		        ('stylist' = ANY( u.role) and u.phone is null)::int is_partial_stylist,	
		        ('client' = ANY( u.role))::int is_client,
		        (inv.created_client_id is not null)::int is_invitation,
		        c.id client_id,
		        s.id stylist_id,
		        u.first_name,
		        u.last_name,
		        u.phone,
		        case when u.email  similar to 'client(-?[0-9a-f]{4}){8}@madebeauty.com' then '' else u.email end email,
		        u.role::varchar roles,
		        s.instagram_url,
		        s.website_url,
		        sl."name" salon_name,
		        sl.address salon_address,
		        (case when u.first_name is null then 0 else 1 end +
			        case when u.last_name is null then 0 else 1 end +
			        case when u.email similar to 'client(-?[0-9a-f]{4}){8}@madebeauty.com' then 0 else 1 end +
			        case when u.phone is null then 0 else 1 end) / 4. client_completeness,
		        (case when u.first_name is null then 0 else 1 end +
			        case when u.last_name is null then 0 else 1 end +
			        case when u.email similar to 'client(-?[0-9a-f]{4}){8}@madebeauty.com' then 0 else 1 end +
			        case when u.phone is null then 0 else 1 end +
			        case when s.instagram_url is null then 0 else 1 end +
			        case when s.website_url is null then 0 else 1 end +
			        case when sl.address is null then 0 else 1 end) / 7. stylist_completeness,
		        case when u.phone is null then 0 else 1 end is_phone,
		        (select count(distinct p3.stylist_id)
			        from public.preferred_stylist p3
			        where p3.client_id = c.id
				        and p3.deleted_at is null) preferred_stylists_count
	        from public.user u
		        left join (
			        select c.user_id, max( i.created_client_id) created_client_id
			        from public.client c
				        left join public.invitation i
					        on c.id = i.created_client_id
			        group by c.user_id) inv
		        on u.id = inv.user_id
		        left join public.stylist s
			        on u.id = s.user_id
		        left join public.salon sl
			        on s.salon_id = sl.id
		        left join public.client c
			        on u.id = c.user_id;
	
	
	        drop view if exists public.rpt_user cascade;
	
	        create or replace view public.rpt_user as
	        select *
	        from public.rpt_all_users
	        where is_staff::int = 0;
	
	
	        drop view if exists public.rpt_users_h cascade;
	
	        create or replace view public.rpt_users_h as
	        select distinct
		        dt.dt,
		        date_trunc( 'week', dt.dt) "week",
		        sum( u.is_client) over (partition by dt.dt) clients,
		        sum( u.is_stylist) over (partition by dt.dt) stylists,
		        sum( u.is_client) over (order by dt.dt) rolling_clients,
		        sum( u.is_stylist) over (order by dt.dt) rolling_stylists,
		        sum( u.is_phone) over (partition by dt.dt) phones,
		        sum( u.is_phone) over (order by dt.dt) rolling_phones,
		        sum( case u.client_completeness when 1 then 1 else 0 end) over (partition by dt.dt) completed_clients,
		        sum( case u.client_completeness when 1 then 1 else 0 end) over (order by dt.dt) rolling_completed_clients
	        from rpt_dates dt
		        left join public.rpt_user u
			        on u.dt_joined = dt.dt
	        where 
		        u.is_staff = 0;
	
	
	        drop view if exists public.rpt_stylist cascade;
	
	        create or replace view public.rpt_stylist as
	        select 
		        st.id stylist_id,
		        coalesce( srv.stylist_services_count, 0) stylist_services_count,
		        srv.avg_regular_price,
		        coalesce( wd.weekday_discounts_count, 0)::int weekday_discounts_count,
		        case when coalesce( wd.weekday_discounts_count, 0) > 0 
			        then 1 else 0 
			        end is_daily_discount,
		        coalesce( wd.avg_weekday_discount, 0) avg_weekday_discount,
		        (0 < any( st.rebook_discounts))::int is_loyalty_discount,
		        case when 0 = all( st.rebook_discounts)
			        then 0::float
			        else
			        (select avg( nullif( discount, 0)) from unnest( st.rebook_discounts) discount)
			        end avg_loyalty_discount,
		        (st.rebook_within_1_week_discount_percent > 0)::int is_first_week_discount,
		        st.first_time_book_discount_percent,
		        st.rebook_within_1_week_discount_percent,
		        (st.maximum_discount > 0 and st.is_maximum_discount_enabled)::int is_maximum_discount_enabled,
		        case when not st.is_maximum_discount_enabled 
			        then null else st.maximum_discount 
			        end maximum_discount,
		        (0 = all( st.rebook_discounts || 
			        array[
				        st.is_maximum_discount_enabled::int4,
				        coalesce( wd.weekday_discounts_count, 0)::int4
				        ]))::int no_discount_count
	        from (
			        select *,
				        array[ rebook_within_1_week_discount_percent,
					        rebook_within_2_weeks_discount_percent,
					        rebook_within_3_weeks_discount_percent, 
					        rebook_within_4_weeks_discount_percent
					        ] rebook_discounts
			        from public.stylist
		        ) st
		        left join (
			        select ss.stylist_id, 
				        count( ss.id) stylist_services_count, 
				        avg( ss.regular_price) avg_regular_price
			        from public.stylist_service ss
			        where ss.is_enabled = true and ss.deleted_at is null
			        group by ss.stylist_id
		        ) srv
			        on st.id = srv.stylist_id
		        left join (
			        select swd.stylist_id, 
				        count( swd.id) weekday_discounts_count,
				        avg( swd.discount_percent) avg_weekday_discount
			        from public.stylist_weekday_discount swd
			        where swd.discount_percent > 0
			        group by swd.stylist_id
		        ) wd
			        on st.id = wd.stylist_id
		        inner join public.rpt_user ss
			        on st.id = ss.stylist_id;
	
	
	        drop view if exists public.rpt_booking cascade;
	
	        create or replace view public.rpt_booking as
	        select
		        b.id,
		        b.datetime_start_at,
		        date_trunc( 'day', b.datetime_start_at) dt_start_at,
		        to_char( b.datetime_start_at, 'YYYY-MM-DD HH24:MI') datetime_start_at_,
		        b.created_at,
		        to_char( b.created_at, 'YYYY-MM-DD HH24:MI') created_at_,
		        case when current_timestamp < date_trunc('day', b.datetime_start_at)::date + interval '1 week' - interval '1 day'  
			        then 1 else null 
			        end :: integer is_last_week,
		        case when current_timestamp < date_trunc('day', b.datetime_start_at)::date + interval '1 month' - interval '1 day'  
			        then 1 else null 
			        end :: integer is_last_month,
		        b.stylist_id,
		        b.status,
		        (b.status = 'checked_out')::int is_checked_out,
		        (b.status in ( 'cancelled_by_client', 'cancelled_by_stylist'))::int is_cancelled,
		        b.grand_total,
		        srv.is_discount,
		        case when srv.discount_amount > 0 
			        then srv.discount_amount else null 
			        end discount_amount,
		        lag( b.datetime_start_at, 1, b.datetime_start_at - interval '100 years') over previous_booking previous_booking_date,
		        (b.datetime_start_at - interval '3 months' <
			        lag( b.datetime_start_at, 1, b.datetime_start_at - interval '100 years') over previous_booking)::int rebooking_3_months,
		        (b.datetime_start_at - interval '6 months' <
			        lag( b.datetime_start_at, 1, b.datetime_start_at - interval '100 years') over previous_booking)::int rebooking_6_months,
		        srv.services_count,
		        (srv.services_count >= 2)::int is_two_and_more_services,
		        trim(b.client_first_name || ' ' || b.client_last_name) client,
		        trim(cc.first_name || ' ' || cc.last_name) client2,
		        b.client_phone,
		        trim(ss.first_name || ' ' || ss.last_name) stylist,
		        ss.phone stylist_phone,
		        sl."name" salon,
		        srv.services,
		        (auto_checkout.appointment_id is not null)::int is_auto_checkout
	        from public.appointment b
		        left join (
			        select s.appointment_id,
				        sum( s.regular_price - s.client_price) discount_amount,
				        max(( s.applied_discount is not null)::int) is_discount,
				        count( s.id) services_count,
				        array_to_string( array_agg( s.service_name || ' ($' || s.regular_price || 
					        ' -' || s.discount_percentage || '% -> $' || s.client_price || ')'), ',
	        ') services
			        from public.appointment_service s
			        group by s.appointment_id
		        ) srv
			        on b.id = srv.appointment_id
		        inner join public.rpt_user sc
			        on b.client_id = sc.client_id
		        inner join public.rpt_user ss
			        on b.stylist_id = ss.stylist_id
		        left join public.stylist s
			        on b.stylist_id = s.id
		        left join public.salon sl
			        on sl.id = s.salon_id
		        left join public.rpt_user cc
		         	on b.created_by_id = cc.id
		         left join (
		         	select distinct h.appointment_id
		         	from public.appointment_status_history h
		         		inner join public."user" bot
			         		on h.updated_by_id = bot.id
		         	where h.status = 'checked_out'
		         		and bot.email = 'auto_appointment_updater@madebeauty.com'
		         ) auto_checkout
		         	on auto_checkout.appointment_id = b.id
	        window previous_booking as (partition by b.client_id order by b.datetime_start_at);
	
	
	        drop view if exists public.rpt_booking_h cascade;
	
	        create or replace view public.rpt_booking_h as
	        select 
		        weekly.dt,
		        weekly.weekly_stylists,
		        weekly.weekly_bookings,
		        case weekly.weekly_stylists 
			        when 0 then null 
			        else weekly.weekly_bookings / weekly.weekly_stylists 
			        end weekly_bookings_per_stylist,
		        weekly_revenue.weekly_avg_stylist_revenue,
		        weekly_revenue.weekly_median_stylist_revenue,
		        monthly.monthly_stylists,
		        monthly.monthly_bookings,
		        case monthly.monthly_stylists
			        when 0 then null
			        else monthly.monthly_bookings / monthly.monthly_stylists 
			        end monthly_bookings_per_stylist,
		        case monthly.monthly_stylists
			        when 0 then null
			        else monthly.monthly_revenue / monthly.monthly_stylists 
			        end monthly_avg_stylist_revenue,
		        sum(daily.daily_bookings) over (partition by daily.dt3) daily_bookings,
		        sum(daily.daily_bookings) over (order by daily.dt3) rolling_daily_bookings,
		        sum(daily.daily_revenue) over (partition by daily.dt3) daily_revenue,
		        sum(daily.daily_revenue) over (order by daily.dt3) rolling_daily_revenue
	        from (
			        select
				        d.dt,
				        count( distinct b.stylist_id) as weekly_stylists,
				        count( b.id) as weekly_bookings
			        from
				        public.rpt_dates d
				        left join public.rpt_booking b
					        on b.dt_start_at between d.dt_week_ago and d.dt
			        where d.is_future = false
			        group by d.dt
		        ) weekly
		        inner join (
			        select
					        d.dt dt2,
					        count( distinct b.stylist_id) as monthly_stylists,
					        count( distinct b.id) as monthly_bookings,
					        sum( b.grand_total) as monthly_revenue
				        from
					        public.rpt_dates d
					        left join public.rpt_booking b
						        on b.dt_start_at between d.dt_month_ago and d.dt
				        where d.is_future = false
				        group by d.dt
		        ) monthly
			        on weekly.dt = monthly.dt2
		        inner join (
			        select
				        r.dt,
				        avg( r.stylist_revenue) weekly_avg_stylist_revenue,
				        percentile_cont( .5) within group (order by r.stylist_revenue) as weekly_median_stylist_revenue
			        from (
				        select 
					        d.dt, 
					        b.stylist_id	,
					        sum( b.grand_total)::float as stylist_revenue
				        from
					        public.rpt_dates d
					        left join public.rpt_booking b
						        on b.dt_start_at between d.dt_week_ago and d.dt
				        where d.is_future = false
				        group by d.dt, b.stylist_id
				        ) r
			        group by r.dt
		        ) weekly_revenue
			        on weekly.dt = weekly_revenue.dt
		        inner join (
			        select
				        d.dt dt3,
				        count( distinct b.stylist_id) as daily_stylists,
				        count( b.id) as daily_bookings,
				        sum( b.grand_total) as daily_revenue
			        from
				        public.rpt_dates d
				        left join public.rpt_booking b
					        on b.dt_start_at = d.dt
			        where d.is_future = false
			        group by d.dt
		        ) daily
			        on weekly.dt = daily.dt3;
	
	
	        drop view if exists public.rpt_appointment_service cascade;
	
	        create or replace view public.rpt_appointment_service as
	        select 
		        aps.service_uuid,
		        a.datetime_start_at,
		        aps.regular_price,
		        aps.client_price,
		        aps.calculated_price
	        from public.appointment_service aps
		        inner join public.appointment a
		        on aps.appointment_id = a.id;
	
	
	        drop view if exists public.rpt_distribution_clients_per_stylists cascade;
	
	        create or replace view public.rpt_distribution_clients_per_stylists as
	        select 
		        current_timestamp datetime,
		        'booking' link_type,
		        a.clients_count, 
		        substring( '   ' || a.clients_count::varchar from '...$') s_clients_count, 
		        count( distinct a.stylist_id) stylist_count
	        from (
		        select count( distinct t.client_id) clients_count, s.stylist_id
		        from public.rpt_user s
			        left join public.appointment t
				        on s.stylist_id = t.stylist_id 
			        left join public.rpt_user c
				        on t.client_id = c.client_id
		        where s.is_stylist = 1
		        group by s.stylist_id
		        ) a
	        group by a.clients_count
	        union all
	        select 
		        current_timestamp datetime,
		        'preferred stylist' link_type,
		        a.clients_count, 
		        substring( '   ' || a.clients_count::varchar from '...$') s_clients_count, 
		        count( distinct a.stylist_id) stylist_count
	        from (
		        select count( distinct t.client_id) clients_count, us.stylist_id
		        from public.rpt_user us
			        left join public.preferred_stylist t
				        on t.stylist_id = us.stylist_id and t.deleted_at is null
			        left join public.rpt_user c
				        on t.client_id = c.client_id
		        where us.is_stylist = 1
		        group by us.stylist_id
		        ) a
	        group by a.clients_count;
	
	
	        drop view if exists public.rpt_distribution_pareto_stylist_client cascade;
	
	        create or replace view public.rpt_distribution_pareto_stylist_client as
	        SELECT 
		        datetime, 
		        clients_percent, 
		        stylist_percent,
		        date '2018-01-01' + round( stylist_percent*100)::integer fake_date
	        FROM (
		        select 
			        current_timestamp datetime,
			        (sum( a.clients_count) over ( order by a.clients_count desc, a.stylist_id))/
				        (sum( a.clients_count) over ( partition by a.g))::float clients_percent, 
			        (count( a.stylist_id) over ( order by a.clients_count desc, a.stylist_id))/
				        (count( a.stylist_id) over ( partition by a.g))::float stylist_percent
		        from (
			        select 
				        count( distinct t.client_id) clients_count, 
				        t.stylist_id, 
				        1 g
			        from public.appointment t
				        inner join public.rpt_user uc
					        on t.client_id = uc.client_id
				        inner join public.rpt_user us
					        on t.stylist_id = us.stylist_id
			        group by t.stylist_id
			        ) a
		        union 
		        select current_timestamp, .0, .0
		        ) T;
	
		
	        drop view if exists public.rpt_distribution_stylists_per_clients cascade;
	
	        create or replace view public.rpt_distribution_stylists_per_clients as
	        select 
		        a.stylists_count, 
		        substring( '   ' || a.stylists_count::varchar from '...$') s_stylists_count, 
		        count( distinct a.client_id) client_count,
		        current_timestamp datetime,
		        'booking'::text AS link_type
	        from (
		        select c.client_id, 
			        count( distinct t.stylist_id) stylists_count
		        from public.rpt_user c
			        left join public.appointment t
				        on t.client_id = c.client_id
			        left join 	public.rpt_user s
				        on t.stylist_id = s.stylist_id
		        where c.is_client = 1
		        group by c.client_id
		        ) a
	        group by a.stylists_count
	        union
	        select 
		        a.stylists_count, 
		        substring( '   ' || a.stylists_count::varchar from '...$') s_stylists_count, 
		        count( distinct a.client_id) client_count,
		        current_timestamp datetime,
	            'preferred stylist'::text AS link_type
	        from (
		        select c.client_id, 
			        count( distinct p.stylist_id) stylists_count
		        from public.rpt_user c
			        left join public.preferred_stylist p
				        on p.client_id = c.client_id and p.deleted_at is null
			        left join 	public.rpt_user s
				        on p.stylist_id = s.stylist_id
		        where c.is_client = 1
		        group by c.client_id
		        ) a
	        group by a.stylists_count;
	
	
        end
        $do$;
        """
        )        
        
        
class Migration(migrations.Migration):

    dependencies = [
        ('core', '0039_auto_20181115_1245'),
        ('appointment', '0035_auto_20181122_0352'),
        ('client', '0025_auto_20181126_0400'),
        ('notifications', '0007_auto_20181115_1213'),
        ('salon', '0071_stylist_deactivated_at')
    ]

    operations = [
        migrations.RunPython(forward, backward),
    ]
